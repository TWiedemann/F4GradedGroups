BaseRing := Rationals;
# ConicAlg contains indeterminates a_1, ... a_{ConicAlg_rank} (and their conjugations)
ConicAlg_rank := 5;
# ComRing contains indeterminates t_1, ..., t_{ComRing_rank} (and the norms and traces of elements of ConicAlg) 
ComRing_rank := 3;
# Let t = Trace_MaxLength. For all k <= t and all i_1, ..., i_k in [ 1..ConicAlg_rank ],
# an indeterminate which represents tr(a_{i_1} ... a_{i_t}) will be created.
# If longer products are needed during the runtime, then an error message is printed.
Trace_MaxLength := 3; 

## ConicAlg indeterminates

# i: Integer.
# Output: Name of the i-th indeterminate in ConicAlg
ConicAlgBasicIndetName := function(i)
	return Concatenation("a", String(i));
end;

# i: Integer.
# Output: Name of the conjugate of the i-th indeterminate in ConicAlg
ConicAlgBasicInvIndetName := function(i)
	return Concatenation("a", String(i), "'");
end;

# Returns the list of all strings which appear as indeterminate names in ConicAlg
_ConicAlgIndetNames := function()
	local ConicAlgIndetNames, i;
	ConicAlgIndetNames := [];
	for i in [1..ConicAlg_rank] do
		Add(ConicAlgIndetNames, ConicAlgBasicIndetName(i));
	od;
	for i in [1..ConicAlg_rank] do
		Add(ConicAlgIndetNames, ConicAlgBasicInvIndetName(i)); # Conjugation
	od;
	return ConicAlgIndetNames;
end;

ConicAlgIndetNames := _ConicAlgIndetNames();

## ComRing indeterminates

# i: Integer.
# Output: Name of the i-th indeterminate of ComRing.
ComRingBasicIndetName := function(i)
	return Concatenation("t", String(i));
end;

# i: Integer with 1 <= i <= ConicAlg_rank.
# Output: The name of the indeterminate of ComRing which represents the norm of a_i
ComRingNormIndetName := function(i)
	if i in [1..ConicAlg_rank] then
		return Concatenation("n(", ConicAlgIndetNames[i], ")");
	else
		return fail;
	fi;
end;

_ConicAlgInvOnIndexList := function(list)
	local result, i;
	result := Reversed(list);
	for i in [1..Length(result)] do
		if result[i] > ConicAlg_rank then
			result[i] := result[i] - ConicAlg_rank;
		else
			result[i] := result[i] + ConicAlg_rank;
		fi;
	od;
	return result;
end;

# indexList: A list of integers i with 1 <= i <= 2*ConicAlg_rank
# Output: The minimal element (w.r.t. the lex order) in the equivalence class of indexList
# w.r.t. to the equivalence relation generated by the following transformations:
# 1. _ConicAlgInvOnIndexList(_) (because tr(a) = tr(a'))
# 2. swapListAtIndex(_, i) for every i (because tr(xy) = tr(yx)).
# The output is regarded as the canonical representative of this class.
_CanonicalIndexList := function(indexList)
	local i, minEntry, minEntryPositions, minEntryInv, minEntryInvPositions,
		candidates, indexListInv;
	indexListInv := _ConicAlgInvOnIndexList(indexList);
	# Find positions of minimal entries in indexList and indexListInv.
	# Only these position have to be considered for swapListAtIndex transformations.
	minEntry := infinity;
	minEntryPositions := [];
	minEntryInv := infinity;
	minEntryInvPositions := [];
	for i in [1..Length(indexList)] do
		# indexList
		if indexList[i] < minEntry then
			minEntry := indexList[i];
			minEntryPositions := [i];
		elif indexList[i] = minEntry then
			Add(minEntryPositions, i);
		fi;
		# indexListInv
		if indexListInv[i] < minEntryInv then
			minEntryInv := indexListInv[i];
			minEntryInvPositions := [i];
		elif indexList[i] = minEntryInv then
			Add(minEntryInvPositions, i);
		fi;
	od;
	# candidates is the list of all elements of the equivalence class which
	# could potentially be minimal.
	if minEntry < minEntryInv then
		candidates := List(minEntryPositions, j -> swapListAtIndex(indexList, j));
	elif minEntry > minEntryInv then
		candidates := List(minEntryInvPositions, j -> swapListAtIndex(indexListInv, j));
	else
		candidates := Concatenation(
			List(minEntryPositions, j -> swapListAtIndex(indexList, j)),
			List(minEntryInvPositions, j -> swapListAtIndex(indexListInv, j))
		);
	fi;
	return Minimum(candidates); # Minimum w.r.t. lex order
end;

# TODO: Remove indet names for tr(a_i a_i') because they are not need (tr(a_i a_i') = 2*n(a_i))
# indexList: A list [i_1, ..., i_k] (for some k) of integers i with 1 <= i <= 2*ConicAlg_rank.
# Output: The name of the indeterminate of ComRing which represents
ComRingTraceIndetName := function(indexList)
	local name, i;
	if Length(indexList) > Trace_MaxLength then
		Error("Product in trace too long");
		return fail;
	fi;
	indexList := _CanonicalIndexList(indexList);
	name := "tr(";
	for i in indexList do
		if not i in [1..2*ConicAlg_rank] then
			return fail;
		else
			name := Concatenation(name, ConicAlgIndetNames[i]);
		fi;
	od;
	name := Concatenation(name, ")");
	return name;
end;

# The elements \gamma_1, ..., \gamma_3 of the diagonal matrix \Gamma which "twists"
# the cubic Jordan matrix algebra.
ComRingGamIndetName := function(i)
	if i in [1, 2, 3] then
		return Concatenation("g", String(i));
	else
		return fail;
	fi;
end;

ComRingIndetNumberForBasic := function(i)
	return i;
end;

ComRingIndetNumberForNorm := function(i)
	return ComRing_rank + i;
end;

# Returns the list of all strings which appear as indeterminate names in ComRing
_ComRingIndetNames := function()
	local ComRingIndetNames, i, j, l, indexList, name;
	ComRingIndetNames := [];
	# Basic indeterminates
	for i in [1..ComRing_rank] do
		Add(ComRingIndetNames, Concatenation("t", String(i)));
	od;
	# Norms
	for i in [1..ConicAlg_rank] do
		Add(ComRingIndetNames, ComRingNormIndetName(i));
	od;
	# Traces
	for l in [1..Trace_MaxLength] do
		indexList := [];
		for i in [1..l] do
			Add(indexList, 1);
		od;
		Add(ComRingIndetNames, ComRingTraceIndetName(indexList)); # Add [ 1, ..., 1 ]
		while true do
			# Increase indexList by one step
			for i in [l, l-1 .. 1 ] do
				if indexList[i] < 2*ConicAlg_rank then
					indexList[i] := indexList[i] + 1;
					for j in [i+1..l] do
						indexList[j] := 1;
					od;
					break;
				elif i = 1 then
					indexList := fail;
				fi;
			od;
			if indexList = fail then
				break;
			else
				name := ComRingTraceIndetName(indexList);
				if not name in ComRingIndetNames then
					Add(ComRingIndetNames, name);
				fi;
			fi;
		od;
	od;
	# \Gamma
	for i in [1,2,3] do
		Add(ComRingIndetNames, ComRingGamIndetName(i));
	od;
	return ComRingIndetNames;
end;

ComRingIndetNames := _ComRingIndetNames();

## Definition of the algebraic structures

ComRing := PolynomialRing(BaseRing, ComRingIndetNames);
ConicAlgMag := FreeMagmaWithOne(ConicAlgIndetNames);
ConicAlg := FreeMagmaRing(ComRing, ConicAlgMag);
ConicAlgMagToAlg := x -> ImageElm(Embedding(ConicAlgMag, ConicAlg), x);
ConicAlgElFam := FamilyObj(Zero(ConicAlg));

ConicAlgMagIndets := GeneratorsOfMagmaWithOne(ConicAlgMag);
embConicAlgMag := x -> ImageElm(Embedding(ConicAlgMag, ConicAlg), x);
ConicAlgIndets := List(ConicAlgMagIndets, embConicAlgMag);

ConicAlgMagBasicIndets := ConicAlgMagIndets{[1..ConicAlg_rank]};
ConicAlgBasicIndets := ConicAlgIndets{[1..ConicAlg_rank]};
ConicAlgMagInvIndets := ConicAlgMagIndets{[ConicAlg_rank+1..2*ConicAlg_rank]};
ConicAlgInvIndets := ConicAlgIndets{[ConicAlg_rank+1..2*ConicAlg_rank]};

## Functions which test requirements and throw errors

DeclareOperation("ReqComRingEl", [IsRingElement]);
DeclareOperation("ReqComRingEl", [IsList]);
DeclareOperation("ReqConicAlgEl", [IsRingElement]);
DeclareOperation("ReqConicAlgEl", [IsList]);

InstallMethod(ReqComRingEl, [IsRingElement], function(a)
	if not IsPolynomial(a) then
		Error("Invalid input: Must be in ComRing.");
		return false;
	fi;
	return true;
end);
InstallMethod(ReqComRingEl, [IsList], function(list)
	local a;
	for a in list do
		if not ReqComRingEl(a) then
			return false;
		fi;
	od;
	return true;
end);

InstallMethod(ReqConicAlgEl, [IsRingElement], function(a)
	if not a in ConicAlg then
		Error("Invalid input: Must be in ConicAlg.");
		return false;
	fi;
	return true;
end);
InstallMethod(ReqConicAlgEl, [IsList], function(list)
	local a;
	for a in list do
		ReqConicAlgEl(a);
	od;
end);

## Constructors for indeterminates

ConicAlgMagBasicIndet := function(i)
	return ConicAlgMagBasicIndets[i];
end;

ConicAlgBasicIndet := function(i)
	return ConicAlgBasicIndets[i];
end;

ConicAlgInvIndet := function(i)
	return ConicAlgInvIndets[i];
end;

ComRingBasicIndet := function(i)
	return Indeterminate(BaseRing, ComRingBasicIndetName(i));
end;

ComRingNormIndet := function(i)
	return Indeterminate(BaseRing, ComRingNormIndetName(i));
end;

ComRingTraceIndet := function(indexList)
	return Indeterminate(BaseRing, ComRingTraceIndetName(indexList));
end;

ComRingGamIndet := function(i)
	return Indeterminate(BaseRing, ComRingGamIndetName(i));
end;

## Functions on the rings

ConicAlgMagInv := function(m)
	local replaceList, replaceByList;
	if not m in ConicAlgMag then
		return fail;
	fi;
	m := reverseInMagma(m);
	replaceList := Concatenation(ConicAlgMagBasicIndets, ConicAlgMagInvIndets);
	replaceByList := Concatenation(ConicAlgMagInvIndets, ConicAlgMagBasicIndets);
	return replaceInMagma(ConicAlgMag, m, replaceList, replaceByList);
end;

ConicAlgInv := function(a)
	if not a in ConicAlg then
		return fail;
	fi;
	return changeRingElByMagmaTrans(ConicAlg, a, ConicAlgMagInv);
end;

# magFunc: A function ConicAlgMag -> ComRing.
# Output: The linear extension ConicAlg -> Comring of magFunc.
# (This is only used for the trace, which makes it a bit useless. I accidentally thought I could use it for the trace and for the norm, but the norm is of course not linear.)
ConicAlgFunctionalFromMagFunctional := function(magFunc)
	return function(a)
		local coeffList, result, i, magmaEl, coeff;
		coeffList := CoefficientsAndMagmaElements(a);
		result := Zero(ComRing);
		for i in [1..Length(coeffList)/2] do
			magmaEl := coeffList[2*i - 1]; # \in ConicAlgMag
			coeff := coeffList[2*i]; # \in ComRing
			result := result + coeff * magFunc(magmaEl);
		od;
		return result;
	end;
end;


ConicAlgMagTrOnRep := function(mRep)
	local assocRep;
	assocRep := assocRepFromNonAssocRep(mRep);
	if IsEmpty(assocRep) then
		return 2*One(ComRing); # Tr(1) = 2
	elif Length(assocRep) = 1 and assocRep[1] in [ConicAlg_rank+1..2*ConicAlg_rank] then
		return ComRingTraceIndet([ assocRep[1] - ConicAlg_rank ]); # Tr(a') = Tr(a)
	else
		return ComRingTraceIndet(assocRep);
	fi;
end;

# We have tr(a_i a_i') = 2*n(a_i). The list _ConicAlgTrExceptions stores the
# elements a_1*a_1', a_1'*a_1, a_2*a_2', ... of ConicAlgMag and _ConicAlgTrExceptionTraces stores
# the corresponding elements 2*n(a_1), 2*n(a_1), 2*n(a_2), ...
# I.e., tr(_ConicAlgTrExceptions[i]) = _ConicAlgTrExceptionTraces[i]
_ComputeConicAlgTrExceptions := function()
	local result, i, a;
	result := [];
	for i in [1..ConicAlg_rank] do
		a := ConicAlgMagBasicIndet(i);
		Add(result, a*ConicAlgMagInv(a));
		Add(result, ConicAlgMagInv(a)*a);
	od;
	return result;
end;

_ComputeConicAlgTrExceptionTraces := function()
	local result, i, a;
	result := [];
	for i in [1..ConicAlg_rank] do
		a := 2*ComRingNormIndet(i);
		Add(result, a);
		Add(result, a);
	od;
	return result;
end;

_ConicAlgTrExceptions := _ComputeConicAlgTrExceptions();
_ConicAlgTrExceptionTraces := _ComputeConicAlgTrExceptionTraces();

ConicAlgMagTr := function(m)
	local k;
	k := Position(_ConicAlgTrExceptions, m);
	if k <> fail then
		return _ConicAlgTrExceptionTraces[k];
	else
		return ConicAlgMagTrOnRep(ExtRepOfObj(m));
	fi;
end;

ConicAlgTr := ConicAlgFunctionalFromMagFunctional(ConicAlgMagTr);

# a, b: Element of ConicAlg.
# Output: n(a,b) such that n(a+b) = n(a) + n(b) + n(a,b).
# By [GPR24, (16.12.4), (16.5.2)], we have n(a,b) = n(1, a'b) = t(a'b)
ConicAlgNormLin := function(a, b)
	ReqConicAlgEl([a,b]);
	return ConicAlgTr(ConicAlgInv(a)*b);
end;

# mRep: ExtRepOfObj of an element of ConicAlgMag
ConicAlgMagNormOnRep := function(mRep)
	if mRep = 0 then # n(1_ConicAlg) = 1_ComRing
		return One(ComRing);
	elif mRep in [1..ConicAlg_rank] then
		return ComRingNormIndet(mRep);
	elif mRep in [ConicAlg_rank+1..2*ConicAlg_rank] then
		return ComRingNormIndet(mRep - ConicAlg_rank);
	elif IsList(mRep) then
		return ConicAlgMagNormOnRep(mRep[1]) * ConicAlgMagNormOnRep(mRep[2]);
	else
		return fail;
	fi;
end;

ConicAlgMagNorm := function(m)
	return ConicAlgMagNormOnRep(ExtRepOfObj(m));
end;

ConicAlgNorm := function(a)
	local coeffList, result, i, j, magmaEl, magmaEl2, coeff, coeff2;
	ReqConicAlgEl(a);
	coeffList := CoefficientsAndMagmaElements(a);
	result := Zero(ComRing);
	for i in [1..Length(coeffList)/2] do
		magmaEl := coeffList[2*i - 1]; # \in ConicAlgMag
		coeff := coeffList[2*i]; # \in ComRing
		result := result + coeff^2 * ConicAlgMagNorm(magmaEl); # norm(x_i)
		for j in [i+1..Length(coeffList)/2] do
			magmaEl2 := coeffList[2*j - 1]; # \in ConicAlgMag
			coeff2 := coeffList[2*j]; # \in ComRing
			result := result + coeff*coeff2 * ConicAlgMagTr(magmaEl * ConicAlgMagInv(magmaEl2)); # tr(x_i x_j') = linearisation of norm
		od;
	od;
	return result;
end;

## ---- Simplifiers ----

# a: Element of ComRing or ConicAlg
# Output: a with all occurences of tr(a_i a_i') replaced by 2n(a_i)
# DeclareOperation("CleanTraces", [IsRingElement]);
# InstallMethod(CleanTraces, [IsRingElement], function(a)
# 	local indets, values, i, a_i, coeffList, newCoeffs, newMagEls;
# 	if a in ComRing then
# 		indets := [];
# 		values := [];
# 		for i in [1..ConicAlg_rank] do
# 			a_i := ConicAlgBasicIndet(i);
# 			Add(indets, ConicAlgTr(a_i * ConicAlgInv(a_i)));
# 			Add(values, 2*ConicAlgNorm(a_i));
# 		od;
# 		# Multiply with 1 to ensure that constant polynomials are in ComRing and
# 		# not in the coefficient ring
# 		return Value(a, indets, values)*One(ComRing);
# 	elif a in ConicAlg then
# 		coeffList := CoefficientsAndMagmaElements(a);
# 		newCoeffs := [];
# 		newMagEls := [];
# 		for i in [1..Length(coeffList)/2] do
# 			Add(newCoeffs, CleanTraces(coeffList[2*i]));
# 			Add(newMagEls, coeffList[2*i - 1]);
# 		od;
# 		return ElementOfMagmaRing(ConicAlgElFam, Zero(ComRing), newCoeffs, newMagEls);
# 	else
# 		Error("Invalid input");
# 		return fail;
# 	fi;
# end);