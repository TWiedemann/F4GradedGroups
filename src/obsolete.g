### Functions that are not longer used but which I do not want to delete

## ----- Root systems -----

# a: A root in F4.
# Output: List of all roots in F4 which are orthogonal to a.
F4OrthoRoots := function(a)
	local result, b;
	result := [];
	for b in F4Roots do
		if a*b = 0 then
			Add(result, b);
		fi;
	od;
	return result;
end;

F4PosOrthoRoots := function(a)
	return Intersection(F4PosRoots, F4OrthoRoots(a));
end;

# root: Element of F4Roots or [0,0,0,0]
# Output: The corresponding root in G2
# Obsolete because a much easier formula without a case distinction is available
F4RootG2Coord := function(root)
	local sum;
	if not root in F4RootsZero then
		Error("Not a root in F4");
		return fail;
	fi;
	# L_2
	if root = [2, 0, 0, 0] then
		return [2, 1];
	# L_{-2}
	elif root = [-2, 0, 0, 0] then
		return [-2, -1];
	# ComRing-parts of the Brown algebra
	elif root = [-1, -1, -1, -1] then
		return [-1, -2];
	elif root = [-1, 1, 1, 1] then
		return [-1, 1];
	elif root = [1, -1, -1, -1] then
		return [1, -1];
	elif root = [1, 1, 1, 1] then
		return [1, 2];
	# L_0
	elif root[1] = 0 then
		sum := Sum(root);
		if sum = 0 then
			return [0, 0];
		elif sum > 0 then
			return [0, 1];
		else
			return [0, -1];
		fi;
	# Cubic-parts of L_{-1}
	elif root[1] = -1 then
		if Sum(root) = 0 then
			return [-1, 0];
		else
			return [-1, -1];
		fi;
	# Cubic-parts of L_1
	else
		if Sum(root) = 0 then
			return [1, 0];
		else
			return [1, 1];
		fi;
	fi;
end;

# root: in F4
# Returns list of all pairs [ root1, root2 ] s.t. root1 + root2 = root and
# root1 appears in F4Roots before root2
F4SumDecomp := function(root)
	local result, i, j, root1, root2;
	result := [];
	for i in [1..Length(F4Roots)] do
		root1 := F4Roots[i];
		for j in [i+1..Length(F4Roots)] do
			root2 := F4Roots[j];
			if root1 + root2 = root then
				Add(result, [root1, root2]);
			fi;
		od;
	od;
	return result;
end;

PrintF4SumDecomp := function(root)
	local entry;
	for entry in F4SumDecomp(root) do
		Print(entry[1], " * ", entry[2], "\n");
	od;
end;

# rootSystem: A root system (as a set of roots, not as a root system in GAP).
# rootList: A subset of rootSystem.
# Output: The root subsystem generated by rootList.
GeneratedSubsystem := function(rootSystem, rootList)
	local vecspace, subspace;
	vecspace := VectorSpace(Rationals, rootSystem);
	subspace := Subspace(vecspace, rootList);
	return Intersection(rootSystem, subspace);
end;

# rootlist: A set of roots in F4RootsLC which forms a root subsystem
# Output: True if this subsystem is of type A_2
SubsystemIsA2 := function(rootlist)
	local vecspace;
	vecspace := VectorSpace(Rationals, rootlist);
	return (Dimension(vecspace) = 2 and Length(rootlist) = 6);
end;

# root: A root in F4
# Output: A list of all subsystems of F4 of type A2 that contain root.
AllA2Subsystems := function(root)
	local result, root2, subsys;
	result := [];
	for root2 in F4Roots do
		subsys := Set(GeneratedSubsystem(F4Roots, [root, root2]));
		if SubsystemIsA2(subsys) and not subsys in result then
			Add(result, subsys);
		fi;
	od;
	return result;
end;

# ----- List utilities -----

# rep: External representation of an element of a free magma. I.e., either an integer or
# a list [ rep1, rep2 ] where rep1, rep2 are external representations.
# Output: The corresponding associative list.
# Example: 0 -> [ ], i -> [ i ], [ [ 1, 2 ], 3 ] -> [ 1, 2, 3 ]
AssocRepFromNonAssocRep := function(rep)
	if rep = 0 then
		return [];
	elif rep in Integers then
		return [ rep ];
	elif IsList(rep) then
		return Concatenation(AssocRepFromNonAssocRep(rep[1]), AssocRepFromNonAssocRep(rep[2]));
	else
		return fail;
	fi;
end;

## Tests
PrintLieComRel := function()
	local i, j, root1, root2, root3, a1, a2, a3, count;
	count := 0;
	for i in [1..Length(F4Roots)] do
		root1 := F4Roots[i];
		if root1 in F4ShortRoots then
			a1 := ConicAlgIndet(1);
		else
			a1 := ComRingIndet(1);
		fi;
		for j in [i+1..Length(F4Roots)] do
			root2 := F4Roots[j];
			if root2 in F4ShortRoots then
				a2 := ConicAlgIndet(2);
			else
				a2 := ComRingIndet(2);
			fi;
			root3 := root1 + root2;
			if root3 in F4ShortRoots then
				a3 := ConicAlgIndet(1);
			elif root3 in F4LongRoots then
				a3 := ComRingIndet(1);
			else
				continue;
			fi;
			count := count+1;
			Print(root1, " * ", root2, ": ", ApplyDistAndPeirceLaw(LieRootHomF4(root1, a1) * LieRootHomF4(root2, a2)), "\n");
			Print(root3, ": ", LieRootHomF4(root3, a3), "\n\n");
		od;
	od;
	Display(count);
end;

# Does not work because e.g. ConicAlgMatTr(a1*a1') = 2*n(a1)
TestWithoutTraces := function()
	local magEls, magEl, test1, test2;
	magEls := Concatenation(_AllConicAlgMagEls(Trace_MaxLength));
	for magEl in magEls do
		test1 := WithoutTraces(ConicAlgMagTr(magEl));
		test2 := ConicAlgMagEmb(magEl) + ConicAlgMagEmb(ConicAlgMagInv(magEl));
		if test1 <> test2 then
			return magEl;
		fi;
	od;
	return true;
end;

## Tests for abstract parametrisation strategy

# relations: A list of lists [l1, l2] where l1 and l2 are lists containing elements
# from [-4, -3, -2, -1, 1, 2, 3, 4] or elements from LieEndo
# The function calls TestRelations on the list weylRelations which is obtained from relations
# by replacing any list [g1, g2, ...] by the automorphism g1 * g2 * ...
# If gi is a positive integer, it is interpreted as w_gi. If it is a negative integer,
# it is interpreted as w_(-gi)^-1. Here wj = GrpStandardWeyl(F4SimpleRoots[j]).
# Uses indeterminates t_1, a_1.
TestWeylRelations := function(relations)
	local w, wInv, i, weylRelations;
	w := [];
	wInv := [];
	for i in [1..Length(F4SimpleRoots)] do
		w[i] := GrpStandardWeylF4(F4SimpleRoots[i]);
		wInv[i] := GrpStandardWeylInvF4(F4SimpleRoots[i]);
	od;
	weylRelations := List(relations, x -> List(x, function(list)
		local auto, i;
		auto := GrpOne;
		for i in list do
			if not IsInt(i) then
				auto := auto * i;
			elif i>0 then
				auto := auto * w[i];
			else
				auto := auto * wInv[-i];
			fi;
		od;
		return auto;
	end));
	return TestRelations(weylRelations);
end;

# Prints all relations which have to be proven by hand to verify the braid relations for
# the standard Weyl elements w.r.t. F4SimpleRoots.
# Uses indeterminates a_1, t_1
TestBraidRel := function()
	return TestWeylRelations([
		[[1, 2, 1], [2, 1, 2]], [[1, 3], [3, 1]], [[1, 4], [4, 1]],
		[[2, 3, 2, 3], [3, 2, 3, 2]], [[2, 4], [4, 2]],
		[[3, 4, 3], [4, 3, 4]]
	]);
end;

# Denote by wi the standard Weyl element for F4SimpleRoots[i]
# This function prints all relations which have to be proven by hand to verify the
# following assertions:
# wi^(wj^2) = wi^-1, wj^(wi^1) = wj^-1 for (i, j) \in {(1,2), (3,4)}
# w2^(w3^2) = w2, w3^(w2^2) = w3^-1
# Note that for i, j with |i-j| > 1, we know from the braid relations that
# wi^(wj^2) = wi.
# Uses indeterminates t_1, a_1.
TestWeylSquareOnWeyl := function()
	return TestWeylRelations([
		[[-1, -1, 2, 1, 1], [-2]], [[-2, -2, 1, 2, 2], [-1]],
		[[-3, -3, 4, 3, 3], [-4]], [[-4, -4, 3, 4, 4], [-3]],
		[[-2, -2, 3, 2, 2], [-3]], [[-3, -3, 2, 3, 3], [2]]
	]);
end;

# Denote by wi the standard Weyl element for F4SimpleRoots[i] by d2, d3 the simple
# roots of index 2 and 3, respectively.
# This function prints all relations which have to be proven by hand to verify the
# following assertions:
# GrpRootHomF4(d2, t1)^(w1^2) = GrpRootHomF4(d2, -t1)
# GrpRootHomF4(d2, t1)^(w2^2) = GrpRootHomF4(d2, t1)
# GrpRootHomF4(d2, t1)^(w3^2) = GrpRootHomF4(d2, t1)
# GrpRootHomF4(d3, a1)^(w2^2) = GrpRootHomF4(d3, -a1)
# GrpRootHomF4(d3, a1)^(w2^2) = GrpRootHomF4(d3, a1)
# GrpRootHomF4(d3, a1)^(w2^2) = GrpRootHomF4(d3, -a1)
# In particular, w1^2, ..., w4^2 normalise the root groups U_d2 and U_d3
# Uses indeterminates t_1, a_1, t_(ComRing_rank), a_(ConicAlg_rank).
TestWeylSquareNormalise := function()
	local a, t, hom2, hom3;
	a := ConicAlgIndet(1);
	t := ComRingIndet(1);
	hom2 := x -> GrpRootHomF4(F4SimpleRoots[2], x);
	hom3 := x -> GrpRootHomF4(F4SimpleRoots[3], x);
	return TestWeylRelations([
		[[-1, -1, hom2(t), 1, 1], [hom2(-t)]],
		[[-2, -2, hom2(t), 2, 2], [hom2(t)]],
		[[-3, -3, hom2(t), 3, 3], [hom2(t)]],
		[[-2, -2, hom3(a), 2, 2], [hom3(-a)]],
		[[-3, -3, hom3(a), 3, 3], [hom3(a)]],
		[[-4, -4, hom3(a), 4, 4], [hom3(-a)]]
	]);
end;

# Denote by wi the standard Weyl element for F4SimpleRoots[i] by d2, d3 the simple
# roots of index 2 and 3, respectively.
# This function prints all relations which have to be proven by hand to verify the
# following assertions:
# - U_d2 is centralised by the following elements:
# -- w4
# -- w4^{w3*w2*w1}
# -- w([1,2,3,2,1,4,3,2,1,3,2,4,3,2,1])
# - U_d3 is centralised by the following elements:
# -- w1
# -- w2^{w3*w4}
# - w([4,3,2,1,3,2,3,4,3,2,1,3,2,3,4]) acts on U_d3 as ConicAlgInv.
TestStabNormalise := function()
	local a, t, hom2, hom3, stab21, stab22, stab23, stab31, stab32, stab33;
	a := ConicAlgIndet(1);
	t := ComRingIndet(1);
	hom2 := x -> GrpRootHomF4(F4SimpleRoots[2], x);
	hom3 := x -> GrpRootHomF4(F4SimpleRoots[3], x);
	# Reduced representations of generators of stabilizer of d2
	stab21 := [4]; # \sigma([0,1,1,0])
	stab22 := [-1, -2, -3, 4, 3, 2, 1]; # \sigma([0,-1,0,1])
	stab23 := [1,2,3,2,1,4,3,2,1,3,2,4,3,2,1]; # \sigma([0,0,0,-2])
	# Reduced representations of generators of stabilizer of d3
	stab31 := [1]; # \sigma([-1,-1,1,1])
	stab32 := [-4,-3,2,3,4]; # \sigma([0,0,-2,0])
	stab33 := [4,3,2,1,3,2,3,4,3,2,1,3,2,3,4]; # \sigma([0,0,1,-1])
	return TestWeylRelations([
		# [Concatenation(-Reversed(stab21), [hom2(t)], stab21), [hom2(t)]],
		# [Concatenation(-Reversed(stab22), [hom2(t)], stab22), [hom2(t)]],
		# [Concatenation(-Reversed(stab23), [hom2(t)], stab23), [hom2(t)]],
		# [Concatenation(-Reversed(stab31), [hom3(a)], stab31), [hom3(a)]],
		# [Concatenation(-Reversed(stab32), [hom3(a)], stab32), [hom3(a)]],
		[Concatenation(-Reversed(stab33), [hom3(a)], stab33), [hom3(ConicAlgInv(a))]]
	]);
end;

## Parity map

# Returns a table par such that par[i][j] is the parity of w_{F4SimpleRoots[j]} on
# U_{F4Roots[i]}
_ComputeF4ParityList := function()
	local d1Par, d2Par, d3Par, d4Par, dPar, root, d1, d2, d3, d4, par, list, j;
	d1 := F4SimpleRoots[1];
	d2 := F4SimpleRoots[2];
	d3 := F4SimpleRoots[3];
	d4 := F4SimpleRoots[4];
	d1Par := NewDictionary(F4Roots[1], true, F4Roots);
	d2Par := NewDictionary(F4Roots[1], true, F4Roots);
	d3Par := NewDictionary(F4Roots[1], true, F4Roots);
	d4Par := NewDictionary(F4Roots[1], true, F4Roots);
	# d1
	for root in F4PosRoots do
		if root in [d1, d1+d2, d1+d2+d3, d1+d2+2*d3, d1+d2+2*d3+d4, d1+d2+2*(d3+d4),
			d1+3*d2+4*d3+2*d4] then
			AddDictionary(d1Par, root, [-1, 1]);
		else
			AddDictionary(d1Par, root, [1, 1]);
		fi;
		AddDictionary(d1Par, -root, LookupDictionary(d1Par, root));
	od;
	# d2
	for root in F4PosRoots do
		if root in [d1, d2, d2+d3, d2+d3+d4, d1+d2+2*d3, d1+d2+2*d3+d4,
			d1+d2+2*(d3+d4), d1+2*d2+4*d3+2*d4] then
			AddDictionary(d2Par, root, [-1, 1]);
		else
			AddDictionary(d2Par, root, [1,1]);
		fi;
		AddDictionary(d2Par, -root, LookupDictionary(d2Par, root));
	od;
	# d3
	for root in F4PosRoots do
		if root in [d2, d3, d1+d2, d2+2*d3, d1+d2+2*d3, d2+2*d3+d4,
			d1+d2+2*d3+d4, d1+2*(d2+d3)+d4, d1+2*(d2+d3+d4), d1+2*d2+4*d3+2*d4] then
			AddDictionary(d3Par, root, [-1, 1]);
		elif root in [d2+d3, d1+d2+d3, d1+2*d2+3*d3+2*d4] then
			AddDictionary(d3Par, root, [-1, -1]);
		else
			AddDictionary(d3Par, root, [1,1]);
		fi;
		AddDictionary(d3Par, -root, LookupDictionary(d3Par, root));
	od;
	# d4
	for root in F4PosRoots do
		if root in [d3, d4, d2+d3, d1+d2+d3, d2+2*d3, d1+d2+2*d3, d1+2*(d2+d3),
			d2+2*(d3+d4), d1+d2+2*(d3+d4), d1+2*(d2+d3+d4), d1+2*d2+3*d3+2*d4] then
			AddDictionary(d4Par, root, [-1, 1]);
		elif root in [d2+2*d3+d4, d1+d2+2*d3+d4, d1+2*(d2+d3)+d4] then
			AddDictionary(d4Par, root, [-1, -1]);
		else
			AddDictionary(d4Par, root, [1,1]);
		fi;
		AddDictionary(d4Par, -root, LookupDictionary(d4Par, root));
	od;
	# Build par
	dPar := [d1Par, d2Par, d3Par, d4Par];
	par := [];
	for root in F4Roots do
		list := [];
		for j in [1..4] do
			Add(list, LookupDictionary(dPar[j], root));
		od;
		Add(par, list);
	od;
	return par;
end;