### This file contains test functions that verify the correctness of certain claims
### in [DMW25].

# ----- Tests involving Weyl elements -----

# root: Root in F4
# refl: Element of LieEndo
# Returns: true if refl permutes the F4-root spaces (including the 0-space) according to refl
# and the induced
# isomorphisms between the root spaces lie in the subgroup generated by { -1, ConicAlgInv }.
# Uses indeterminates a_{ConicAlg_rank-1}, a_{ConicAlg_rank}, t_{ComRing_rank}.
TestReflection := function(root, refl)
	local alpha, a, candidates, b, alphaRefl, testEl, isOk, gen;
	# Check on root spaces
	for alpha in F4Roots do
		if alpha in F4ShortRoots then
			a := ConicAlgIndet(ConicAlg_rank);
			candidates := [a, -a, ConicAlgInv(a), -ConicAlgInv(a)];
		else
			a := ComRingIndet(ComRing_rank);
			candidates := [a, -a];
		fi;
		alphaRefl := F4Refl(alpha, root);
		testEl := refl(LieRootHomF4(alpha, a));
		isOk := false;
		for b in candidates do
			if TestEquality(testEl, LieRootHomF4(alphaRefl, b)) = true then
				isOk := true;
				break;
			fi;
		od;
		if not isOk then
			return false;
		fi;
	od;
	# Check on L_0000
	for gen in Lie0000Gens(1, ConicAlg_rank-1) do
		if not IsInLie0000(Simplify(refl(gen))) then
			return false;
		fi;
	od;
	return true;
end;

# Returns: true if GrpStandardWeylF4(root) is a reflection for all root \in F4.
TestAllReflections := function()
	local root;
	for root in F4Roots do
		if TestReflection(root, GrpStandardWeylF4(root)) = false then
			return false;
		fi;
	od;
	return true;
end;

## In the follwing, a "parity" is a list of the form [1,1], [1,-1], [-1,1] or [-1,-1].
## It represents the corresponding element of the twisting group of (ComRing, ConicAlg).
## That is, the first component represents the inversion action on ComRing and on ConicAlg
## and the second component represents the conjugation on ConicAlg.

# w, wInv: Elements of LieEndo. It is assumed that wInv = w^-1.
# root: Element of F4. It is assumed that w is a Weyl element w.r.t. this root.
# onRootList: List of roots on which conjugation by w is tested.
# Returns: A list [pars, errors] where:
# - pars is a list such that pars[i] is the parity of w on the root group with
# respect to onRootList[i].
# - errors is either true or a list consisting of Lie algebra elements which have to
# be proven to be zero to show that w acts with the parities in pars.
# (To decide which parity to return, the twist with the shortest error list is chosen. There
# is no guarantee that this is the correct twist, but it works and will be verified
# by hand by proving that all elements in the error list are actually zero.)
# Uses indeterminates a_1, t_1, a_{ConicAlg_rank}, t_{ComRing_rank}
_WeylErrorAndParity := function(root, onRootList, w, wInv)
	local baseRoot, baseRootErrorList, isWeylOnBaseRoot, errors, a, x, twistList,
		t, b, y, test, i, pars, par, parList;
	errors := [];
	pars := [];
	# Check action on all root groups w.r.t. onRootList
	for baseRoot in onRootList do
		# Define root group element x on which we act
		if baseRoot in F4ShortRoots then
			a := ConicAlgIndet(1);
			x := GrpRootHomF4(baseRoot, a, true, true);
			twistList := [a, -a, ConicAlgInv(a), -ConicAlgInv(a)];
			parList := [[1,1], [-1,1], [1,-1], [-1,-1]];
		else
			t := ComRingIndet(1);
			x := GrpRootHomF4(baseRoot, t, true, true);
			twistList := [t, -t];
			parList := [[1,1], [-1,1]];
		fi;
		isWeylOnBaseRoot := false; # whether wInv*x*w has been proven to be of the desired form
		baseRootErrorList := fail;
		par := fail;
		for i in [1..Length(parList)] do
			b := twistList[i];
			y := GrpRootHomF4(F4Refl(baseRoot, root), b, true, true);
			test := TestEquality(wInv*x*w, y);
			if test = true then
				isWeylOnBaseRoot := true;
				par := parList[i];
				break;
			# Keep twist with shortest error list
			elif baseRootErrorList = fail or Length(test) < Length(baseRootErrorList) then
				baseRootErrorList := test;
				par := parList[i];
			fi;
		od;
		Add(pars, par);
		# There remain error terms that have to be proven to be zero by hand
		if not isWeylOnBaseRoot then
			errors := Concatenation(errors, List(baseRootErrorList, x -> x[2]));
		fi;
	od;
	if IsEmpty(errors) then
		return [pars, true];
	else
		return [pars, errors];
	fi;
end;

# Returns: The first element of the output of _WeylErrorAndParity, i.e., the list of parities
WeylParityList := function(root, onRootList, w, wInv)
	return _WeylErrorAndParity(root, onRootList, w, wInv)[1];
end;

# w, wInv: Elements of LieEndo. It is assumed that wInv = w^-1.
# root: Element of F4. It is assumed that w is a Weyl element w.r.t. this root.
# parList: A list with 48 entries of the form [+-1, +-1]
# Returns: true if w can be proven to be a root-Weyl element such that the parity of w
# on F4Roots[i] is precisely parList[i].
# Otherwise the output is a list of elements of ComRing, ConicAlg and L0 which have to
# be proven by hand to be zero to show that w is a root-Weyl element with the desired
# parity.
# Uses indeterminates a_1, t_1, a_{ConicAlg_rank}, t_{ComRing_rank}
TestWeylParity := function(root, w, wInv, parList)
	local baseRoot, errorList, a, x, b, y, test, i, par;
	errorList := [];
	for i in [1..Length(F4Roots)] do
		baseRoot := F4Roots[i];
		par := parList[i];
		if baseRoot in F4ShortRoots then
			a := ConicAlgIndet(1);
		else
			a := ComRingIndet(1);
		fi;
		x := GrpRootHomF4(baseRoot, a);
		# b is a twisted by par
		b := a;
		if par[1] = -1 then
			b := -b;
		fi;
		if par[2] = -1 then
			b := ConicAlgInv(b);
		fi;
		y := GrpRootHomF4(F4Refl(baseRoot, root), b);
		test := TestEqualityPieces(wInv*x*w, y);
		errorList := Concatenation(errorList, test);
	od;
	if IsEmpty(errorList) then
		return true;
	else
		return errorList;
	fi;
end;

# Returns: List of Lie algebra elements that have to be proven to be zero to show that
# F4SimpleRootParList is correct (i.e. F4SimpleRootParList[i][j] is the parity of
# GrpStandardWeylF4(F4SimpleRoots[i]) on the root group of F4Roots[j]).
# Uses indeterminates a_1, t_1, a_{ConicAlg_rank}, t_{ComRing_rank}.
# true for F4SimpleRoots[1] and F4SimpleRoots[2]
TestSimpleRootParLists := function()
	local errorList, i, root, w, wInv, parList, test;
	errorList := [];
	for i in [1..4] do
		root := F4SimpleRoots[i];
		w := GrpStandardWeylF4(root, 1);
		wInv := GrpStandardWeylF4(root, -1);
		parList := F4SimpleRootParLists[i];
		test := TestWeylParity(root, w, wInv, parList);
		if test <> true then
			errorList := Concatenation(errorList, test);
		fi;
	od;
	return errorList;
end;

# ----- Tests involving commutator relations in the group -----

# root1, root2: Roots in F4 of the same length.
# a1, a2: Elements of ComRing if root1, root2 are long and elements of ConicAlg otherwise.
# Returns: The commutator of the root group elements determined by [root1, a1]
# and [root2, a2].
GrpRootHomCom := function(root1, a1, root2, a2)
	local hom;
	hom := function(root, a)
		return GrpRootHomF4(root, a);
	end;
	return hom(root1, -a1)*hom(root2, -a2)*hom(root1, a1)*hom(root2, a2);
end;

# Returns: A list of all relations which have to be verified by hand to prove that
# all desired F4-commutator relations in [DMW] are satisfied.
# Uses indeterminates t_1, t_2, t_{ComRing_rank} a_1, a_2, a_{ConicAlg_rank} and assumes
# that both ranks are > 2.
TestGrpComRels := function()
	local t1, t2, a1, a2, d1, d2, d3, d4, g1, g2, g3, comm, test, rel;
	t1 := ComRingIndet(1);
	t2 := ComRingIndet(2);
	a1 := ConicAlgIndet(1);
	a2 := ConicAlgIndet(2);
	d1 := F4SimpleRoots[1];
	d2 := F4SimpleRoots[2];
	d3 := F4SimpleRoots[3];
	d4 := F4SimpleRoots[4];
	g1 := ComRingGamIndet(1);
	g2 := ComRingGamIndet(2);
	g3 := ComRingGamIndet(3);
	return TestEqualityPiecesOnList([
		# Commutator relation on [d1, d2]
		[GrpRootHomCom(d1, t1, d2, t2), GrpRootHomF4(d1+d2, t1*t2)],
		# Commutator relation on [d2, d3]
		[
			GrpRootHomCom(d2, t1, d3, a1),
			GrpRootHomF4(d2+d3, -t1*a1) * GrpRootHomF4(d2+2*d3, t1*ConicAlgNorm(a1))
		],
		# Commutator relation on [d2+d3, d3]
		[
			GrpRootHomCom(d2+d3, a1, d3, a2),
			GrpRootHomF4(d2+2*d3, -ConicAlgTr(a1 * ConicAlgInv(a2)))
		],
		# Commutator relation on [d2, d2+2*d3]
		[
			GrpRootHomCom(d2, t1, d2+2*d3, t2),
			GrpOne
		],
		# Commutator relation on [d3, d4]
		[GrpRootHomCom(d4, a1, d3, a2), GrpRootHomF4(d3+d4, ConicAlgInv(a2)*ConicAlgInv(a1))]
	]);
end;

# ----- Tests involving the Chevalley-type basis -----

# Returns: true if c(root1, root2) = -c(-root1, -root2) for all roots root1, root2 in F4 or G2
# where c denotes the Chevalley structure constant
TestChevStrucConstSigns := function()
	local i, j, k, root1, root2, roots, c;
	for k in [1,2] do
		if k=1 then
			roots := F4Roots;
			c := ChevStrucConst;
		else
			roots := G2Roots;
			c := ChevStrucConst;
		fi;
		for i in [1..Length(roots)] do
			# We only need to test for i<j because c(a,b) = -c(b,a)
			for j in [i+1..Length(roots)] do
				root1 := roots[i];
				root2 := roots[j];
				if c(root1, root2) <> -c(-root1, -root2) then
					return false;
				fi;
			od;
		od;
	od;
	return true;
end;

# root: Root in F4 or G2.
# Returns: true if ChevHEl(root) acts as the scalar CartanInt(alpha, root)
# on every root space L_alpha of Lie, and false otherwise
TestChevHOnRoot := function(root)
	local h, alpha, a, x, coeff, roots, cartan, hEl, chev;
	if root in F4Roots then
		roots := F4Roots;
		cartan := F4CartanInt;
		hEl := ChevHEl;
		chev := ChevBasEl;
	elif root in G2Roots then
		roots := G2Roots;
		cartan := G2CartanInt;
		hEl := ChevG2HEl;
		chev := ChevG2BasEl;
	else
		return fail;
	fi;
	h := hEl(root);
	for alpha in roots do
		x := chev(alpha);
		coeff := cartan(alpha, root) * One(ComRing);
		if Simplify(h*x - coeff*x) <> LieZero then
			return false;
		fi;
	od;
	return true;
end;

# Returns: true if TestChevHOnRoot(alpha) = true for all alpha \in F4 and all alpha \in G2, and
# false otherwise.
TestChevH := function()
	local root;
	for root in Concatenation(F4Roots, G2Roots) do
		if TestChevHOnRoot(root) = false then
			return false;
		fi;
	od;
	return true;
end;

# ----- Tests involving commutator relations in the Lie algebra -----

# root1, root2: Roots in F4.
# Returns: If root1=-root2, returns true. If root1+root2 is not a root and not zero,
# returns true if the commutator formula
# LieRootHomF4(root1, a) * LieRootHomF4(root2, b) = 0
# is satisfied. In any other case, returns true if the commutator formula
# LieRootHomF4(root1, a) * LieRootHomF4(root2, b) = LieRootHomF4(root1+root2, p)
# is satisfied for some p, which may be one of the following:
# - ChevStrucConst(root1, root2)/2 * tr(c*d) if root1+root2 is long and
# one of root1, root2 is short. (In this case, by TestF4RootLengthSum(),
# both root1, root2 are short.)
# - ChevStrucConst(root1, root2) * e otherwise
# where c in [a,a'], d in [b,b'], e in [c*d, d*c].
# Uses indeterminates t_1, t_2, a_1, a_2.
TestLieComRel := function(root1, root2)
	local roots, t, a, i, c, param, lie, comm, test, prod, p1, p2, par;
	roots := [root1, root2, root1+root2];
	t := [ComRingIndet(1), ComRingIndet(2)];
	a := [ConicAlgIndet(1), ConicAlgIndet(2)];
	# Initialisation: lie contains the two Lie algebra elements whose commutator
	# is tested. param[i] contains the parameters which are later tested for the
	# commutator formula.
	param := [];
	lie := [];
	for i in [1,2] do
		if roots[i] in F4ShortRoots then
			param[i] := [a[i], ConicAlgInv(a[i])];
		else
			param[i] := [t[i]];
		fi;
		lie[i] := LieRootHomF4(roots[i], param[i][1]);
	od;
	# Test
	comm := Simplify(lie[1]*lie[2]);
	c := ChevStrucConst(root1, root2);
	for p1 in param[1] do
		for p2 in param[2] do
			prod := c*p1*p2;
			if roots[3] in F4ShortRoots then
				# In this case, one of root1 and root2 must be short, so prod lies in ConicAlg
				for par in [prod, ConicAlgInv(prod)] do
					test := LieRootHomF4(roots[3], par);
					if TestEquality(comm, test) then
						return true;
					fi;
				od;
			elif roots[3] in F4LongRoots then
				if root1 in F4ShortRoots or root2 in F4ShortRoots then # prod in ConicAlg
					# Remove factor that is contained in c because it is
					# "already covered by the trace map", and replace prod by a trace
					if not IsEvenInt(c) then
						return false;
					fi;
					prod := ConicAlgTr(c/2 * p1 * p2);
				fi;
				test := LieRootHomF4(roots[3], prod);
				if TestEquality(comm, test) then
					return true;
				fi;
			elif roots[3] <> [0,0,0,0] then
				test := LieZero;
				if TestEquality(comm, test) then
					return true;
				fi;
			else
				# No commutator relation to test for [L_alpha, L_{-alpha}]
				return true;
			fi;
		od;
	od;
	return false;
end;

# Returns: true if TestLieComRel succeeds for all pairs of roots in F4, and false otherwise.
TestLieComRels := function()
	local root1, root2;
	for root1 in F4Roots do
		for root2 in F4Roots do
			if not TestLieComRel(root1, root2) then
				Print(root1, ", ", root2, "\n");
				return false;
			fi;
		od;
	od;
	return true;
end;

# ----- Misc -----

# Returns: true if the content of _ComRingIndetInfo is correct
TestComRingIndetInfo := function()
	local i, info, type, indet;
	for i in [1..Length(_ComRingIndetInfo)] do
		info := _ComRingIndetInfo[i];
		type := info[1];
		info := info[2];
		indet := Indeterminate(BaseRing, i);
		if (type = "t" and indet <> ComRingIndet(info))
			or (type = "g" and indet <> ComRingGamIndet(info))
			or (type = "n" and indet <> ConicAlgMagNorm(info))
			or (type = "tr" and indet <> ConicAlgMagTr(info)) then
			return i;
		fi;
	od;
	return true;
end;

# Returns: true if for all roots a, b in F4 with a+b \in F4, the following hold:
# - If b and a+b are long, then a is long.
# - If b is long and a+b is short, then a is short.
# Otherwise returns false.
# (Returns true.)
TestF4RootLengthSum := function()
	local a,b;
	for a in F4Roots do
		for b in F4Roots do
			if not a+b in F4Roots then
				continue;
			fi;
			if b in F4LongRoots and a+b in F4LongRoots and a in F4ShortRoots then
				return false;
			elif b in F4LongRoots and a+b in F4ShortRoots and a in F4LongRoots then
				return false;
			fi;
		od;
	od;
	return true;
end;

# TODO: Check.
# Prints F4SimpleRootParLists as a LaTeX table
printLatexParityTable := function()
	local e1, e2, e3, e4, rootCoeffs, rootCoeff, root, pos, i, k, l, par;
	Display("\\toprule");
	Display("$\\alpha$ & $\\tilde{\\eta}(\\alpha, f_1)$ & $\\tilde{\\eta}(\\alpha, f_2)$ & $\\tilde{\\eta}(\\alpha, f_3)$ & $\\tilde{\\eta}(\\alpha, f_4)$ \\\\");
	e1 := [1,0,0,0];
	e2 := [0,1,0,0];
	e3 := [0,0,1,0];
	e4 := [0,0,0,1];
	rootCoeffs := [ 
		e1, e2, e3, e4, e1+e2, e2+e3, e3+e4, e1+e2+e3, e2+2*e3, e2+e3+e4, e1+e2+2*e3, 
		e1+e2+e3+e4, e2+2*e3+e4, e1+2*e2+2*e3, e1+e2+2*e3+e4, e2+2*e3+2*e4, e1+2*e2+2*e3+e4, 
		e1+e2+2*e3+2*e4, e1+2*e2+3*e3+e4, e1+2*(e2+e3+e4), e1+2*e2+3*e3+2*e4, e1+2*e2+4*e3+2*e4, 
		e1+3*e2+4*e3+2*e4, 2*e1+3*e2+4*e3+2*e4 
	]; # Positive roots in the desired order, expressed as linear combinations of F4SimpleRoots
	for i in [1..Length(rootCoeffs)] do
		if IsInt((i-1)/5) then
			Display("\\midrule");
		fi;
		rootCoeff := rootCoeffs[i];
		root := rootCoeff * F4SimpleRoots;
		pos := Position(F4Roots, root);
		# Print rootCoeff
		for k in rootCoeff do
			Print(k);
		od;
		# Print parities
		for l in [1..4] do
			Print(" & ");
			par := F4SimpleRootParLists[l][pos];
			Print("$ (", par[1], ", ", par[2], ") $");
		od;
		Print("\\\\\n");
	od;
	Display("\\bottomrule");
end;
