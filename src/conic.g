BaseRing := Rationals;
# ConicAlg contains indeterminates a_1, ... a_{ConicAlg_rank} (and their conjugations)
ConicAlg_rank := 5;
# ComRing contains indeterminates t_1, ..., t_{ComRing_rank} (and the norms and traces of elements of ConicAlg) 
ComRing_rank := 5;
# Let t = Trace_MaxLength. For all k <= t and all i_1, ..., i_k in [ 1..ConicAlg_rank ],
# an indeterminate which represents tr(a_{i_1} ... a_{i_t}) will be created.
# If longer products are needed during the runtime, then an error message is printed.
Trace_MaxLength := 4; 

## ConicAlg indeterminates

# i: Integer.
# Output: Name of the i-th indeterminate in ConicAlg
ConicAlgBasicIndetName := function(i)
	return Concatenation("a", String(i));
end;

# i: Integer.
# Output: Name of the conjugate of the i-th indeterminate in ConicAlg
ConicAlgBasicInvIndetName := function(i)
	return Concatenation("a", String(i), "'");
end;

# Returns the list of all strings which appear as indeterminate names in ConicAlg
_ConicAlgIndetNames := function()
	local ConicAlgIndetNames, i;
	ConicAlgIndetNames := [];
	for i in [1..ConicAlg_rank] do
		Add(ConicAlgIndetNames, ConicAlgBasicIndetName(i));
	od;
	for i in [1..ConicAlg_rank] do
		Add(ConicAlgIndetNames, ConicAlgBasicInvIndetName(i)); # Conjugation
	od;
	return ConicAlgIndetNames;
end;

ConicAlgIndetNames := _ConicAlgIndetNames();

## ComRing indeterminates

# i: Integer.
# Output: Name of the i-th indeterminate of ComRing.
ComRingBasicIndetName := function(i)
	return Concatenation("t", String(i));
end;

# i: Integer with 1 <= i <= ConicAlg_rank.
# Output: The name of the indeterminate of ComRing which represents the norm of a_i
ComRingNormIndetName := function(i)
	if i in [1..ConicAlg_rank] then
		return Concatenation("n(", ConicAlgIndetNames[i], ")");
	else
		return fail;
	fi;
end;

# Obsolete because < does the same
# list1, list2: Lists of integers of the same length.
# Output: true if list1 <= list2 w.r.t the lex order, false otherwise.
# _LexSmallerEqual := function(list1, list2)
# 	local l, i;
# 	l := Length(list1);
# 	if Length(list2) <> l then
# 		Error("Lists do not have the same length");
# 		return fail;
# 	fi;
# 	for i in [1..l] do
# 		if list1[i] < list2[i] then
# 			return true;
# 		elif list1[i] > list2[i] then
# 			return false;
# 		fi;
# 	od;
# 	# list1 = list2
# 	return true;
# end;

_ConicAlgInvOnIndexList := function(list)
	local result, i;
	result := Reversed(list);
	for i in [1..Length(result)] do
		if result[i] > ConicAlg_rank then
			result[i] := result[i] - ConicAlg_rank;
		else
			result[i] := result[i] + ConicAlg_rank;
		fi;
	od;
	return result;
end;

# indexList: A list of integers i with 1 <= i <= 2*ConicAlg_rank
# Output: The minimal element (w.r.t. the lex order) in the equivalence class of indexList
# w.r.t. to the equivalence relation generated by the following transformations:
# 1. _ConicAlgInvOnIndexList(_) (because tr(a) = tr(a'))
# 2. swapListAtIndex(_, i) for every i (because tr(xy) = tr(yx)).
# The output is regarded as the canonical representative of this class.
_CanonicalIndexList := function(indexList)
	local i, minEntry, minEntryPositions, minEntryInv, minEntryInvPositions,
		candidates, indexListInv;
	indexListInv := _ConicAlgInvOnIndexList(indexList);
	# Find positions of minimal entries in indexList and indexListInv.
	# Only these position have to be considered for swapListAtIndex transformations.
	minEntry := infinity;
	minEntryPositions := [];
	minEntryInv := infinity;
	minEntryInvPositions := [];
	for i in [1..Length(indexList)] do
		# indexList
		if indexList[i] < minEntry then
			minEntry := indexList[i];
			minEntryPositions := [i];
		elif indexList[i] = minEntry then
			Add(minEntryPositions, i);
		fi;
		# indexListInv
		if indexListInv[i] < minEntryInv then
			minEntryInv := indexListInv[i];
			minEntryInvPositions := [i];
		elif indexList[i] = minEntryInv then
			Add(minEntryInvPositions, i);
		fi;
	od;
	# candidates is the list of all elements of the equivalence class which
	# could potentially be minimal.
	if minEntry < minEntryInv then
		candidates := List(minEntryPositions, j -> swapListAtIndex(indexList, j));
	elif minEntry > minEntryInv then
		candidates := List(minEntryInvPositions, j -> swapListAtIndex(indexListInv, j));
	else
		candidates := Concatenation(
			List(minEntryPositions, j -> swapListAtIndex(indexList, j)),
			List(minEntryInvPositions, j -> swapListAtIndex(indexListInv, j))
		);
	fi;
	return Minimum(candidates); # Minimum w.r.t. lex order
end;

# indexList: A list [i_1, ..., i_k] (for some k) of integers i with 1 <= i <= 2*ConicAlg_rank.
# Output: The name of the indeterminate of ComRing which represents
ComRingTraceIndetName := function(indexList)
	local name, i;
	if Length(indexList) > Trace_MaxLength then
		Error("Product in trace too long");
		return fail;
	fi;
	indexList := _CanonicalIndexList(indexList);
	name := "tr(";
	for i in indexList do
		if not i in [1..2*ConicAlg_rank] then
			return fail;
		else
			name := Concatenation(name, ConicAlgIndetNames[i]);
		fi;
	od;
	name := Concatenation(name, ")");
	return name;
end;

# The elements \gamma_1, ..., \gamma_3 of the diagonal matrix \Gamma which "twists"
# the cubic Jordan matrix algebra.
ComRingGamIndetName := function(i)
	if i in [1, 2, 3] then
		return Concatenation("g", String(i));
	else
		return fail;
	fi;
end;

ComRingIndetNumberForBasic := function(i)
	return i;
end;

ComRingIndetNumberForNorm := function(i)
	return ComRing_rank + i;
end;

# Returns the list of all strings which appear as indeterminate names in ComRing
_ComRingIndetNames := function()
	local ComRingIndetNames, i, j, l, indexList, name;
	ComRingIndetNames := [];
	# Basic indeterminates
	for i in [1..ComRing_rank] do
		Add(ComRingIndetNames, Concatenation("t", String(i)));
	od;
	# Norms
	for i in [1..ConicAlg_rank] do
		Add(ComRingIndetNames, ComRingNormIndetName(i));
	od;
	# Traces
	for l in [1..Trace_MaxLength] do
		indexList := [];
		for i in [1..l] do
			Add(indexList, 1);
		od;
		Add(ComRingIndetNames, ComRingTraceIndetName(indexList)); # Add [ 1, ..., 1 ]
		while true do
			# Increase indexList by one step
			for i in [l, l-1 .. 1 ] do
				if indexList[i] < 2*ConicAlg_rank then
					indexList[i] := indexList[i] + 1;
					for j in [i+1..l] do
						indexList[j] := 1;
					od;
					break;
				elif i = 1 then
					indexList := fail;
				fi;
			od;
			if indexList = fail then
				break;
			else
				name := ComRingTraceIndetName(indexList);
				if not name in ComRingIndetNames then
					Add(ComRingIndetNames, name);
				fi;
			fi;
		od;
	od;
	# \Gamma
	for i in [1,2,3] do
		Add(ComRingIndetNames, ComRingGamIndetName(i));
	od;
	return ComRingIndetNames;
end;

ComRingIndetNames := _ComRingIndetNames();

## Definition of the algebraic structures

ComRing := PolynomialRing(BaseRing, ComRingIndetNames);
ConicAlgMag := FreeMagmaWithOne(ConicAlgIndetNames);
ConicAlg := FreeMagmaRing(ComRing, ConicAlgMag);

ConicAlgMagIndets := GeneratorsOfMagmaWithOne(ConicAlgMag);
embConicAlgMag := x -> ImageElm(Embedding(ConicAlgMag, ConicAlg), x);
ConicAlgIndets := List(ConicAlgMagIndets, embConicAlgMag);

ConicAlgMagBasicIndets := ConicAlgMagIndets{[1..ConicAlg_rank]};
ConicAlgBasicIndets := ConicAlgIndets{[1..ConicAlg_rank]};
ConicAlgMagInvIndets := ConicAlgMagIndets{[ConicAlg_rank+1..2*ConicAlg_rank]};
ConicAlgInvIndets := ConicAlgIndets{[ConicAlg_rank+1..2*ConicAlg_rank]};

## Functions which test requirements and throw errors

DeclareOperation("ReqComRingEl", [IsRingElement]);
DeclareOperation("ReqComRingEl", [IsList]);
DeclareOperation("ReqConicAlgEl", [IsRingElement]);
DeclareOperation("ReqConicAlgEl", [IsList]);

InstallMethod(ReqComRingEl, [IsRingElement], function(a)
	if not a in ComRing then
		Error("Invalid input: Must be in ComRing.");
		return false;
	fi;
	return true;
end);
InstallMethod(ReqComRingEl, [IsList], function(list)
	local a;
	for a in list do
		if not ReqComRingEl(a) then
			return false;
		fi;
	od;
	return true;
end);

InstallMethod(ReqConicAlgEl, [IsRingElement], function(a)
	if not a in ConicAlg then
		Error("Invalid input: Must be in ConicAlg.");
		return false;
	fi;
	return true;
end);
InstallMethod(ReqConicAlgEl, [IsList], function(list)
	local a;
	for a in list do
		ReqConicAlgEl(a);
	od;
end);

## Constructors for indeterminates

ConicAlgBasicIndet := function(i)
	return ConicAlgBasicIndets[i];
end;

ConicAlgInvIndet := function(i)
	return ConicAlgInvIndets[i];
end;

ComRingBasicIndet := function(i)
	return Indeterminate(BaseRing, ComRingBasicIndetName(i));
end;

ComRingNormIndet := function(i)
	return Indeterminate(BaseRing, ComRingNormIndetName(i));
end;

ComRingTraceIndet := function(indexList)
	return Indeterminate(BaseRing, ComRingTraceIndetName(indexList));
end;

ComRingGamIndet := function(i)
	return Indeterminate(BaseRing, ComRingGamIndetName(i));
end;

## Functions on the rings

ConicAlgMagInv := function(m)
	local replaceList, replaceByList;
	if not m in ConicAlgMag then
		return fail;
	fi;
	m := reverseInMagma(m);
	replaceList := Concatenation(ConicAlgMagBasicIndets, ConicAlgMagInvIndets);
	replaceByList := Concatenation(ConicAlgMagInvIndets, ConicAlgMagBasicIndets);
	return replaceInMagma(ConicAlgMag, m, replaceList, replaceByList);
end;

ConicAlgInv := function(a)
	if not a in ConicAlg then
		return fail;
	fi;
	return changeRingElByMagmaTrans(ConicAlg, a, ConicAlgMagInv);
end;

# magFunc: A function ConicAlgMag -> Comring.
# Outpunt: The linear extension ConicAlg -> Comring of magFunc.
# (This is only used for the trace, which makes it a bit useless. I accidentally thought I could use it for the trace and for the norm, but the norm is of course not linear.)
ConicAlgFunctionalFromMagFunctional := function(magFunc)
	return function(a)
		local coeffList, result, i, magmaEl, coeff;
		coeffList := CoefficientsAndMagmaElements(a);
		result := Zero(ComRing);
		for i in [1..Length(coeffList)/2] do
			magmaEl := coeffList[2*i - 1]; # \in ConicAlgMag
			coeff := coeffList[2*i]; # \in ComRing
			result := result + coeff * magFunc(magmaEl);
		od;
		return result;
	end;
end;



# ConicAlgNorm := ConicAlgFunctionalFromMagFunctional(ConicAlgMagNorm);

ConicAlgMagTrOnRep := function(mRep)
	local assocRep;
	assocRep := assocRepFromNonAssocRep(mRep);
	if IsEmpty(assocRep) then
		return 2*One(ComRing); # Tr(1) = 2
	elif Length(assocRep) = 1 and assocRep[1] in [ConicAlg_rank+1..2*ConicAlg_rank] then
		return ComRingTraceIndet([ assocRep[1] - ConicAlg_rank ]); # Tr(a') = Tr(a)
	else
		return ComRingTraceIndet(assocRep);
	fi;
end;

ConicAlgMagTr := function(m)
	return ConicAlgMagTrOnRep(ExtRepOfObj(m));
end;

ConicAlgTr := ConicAlgFunctionalFromMagFunctional(ConicAlgMagTr);

# a, b: Element of ConicAlg.
# Output: n(a,b) such that n(a+b) = n(a) + n(b) + n(a,b).
# By [GPR24, (16.12.4), (16.5.2)], we have n(a,b) = n(1, a'b) = t(a'b)
ConicAlgNormLin := function(a, b)
	ReqConicAlgEl([a,b]);
	return ConicAlgTr(ConicAlgInv(a)*b);
end;

# mRep: ExtRepOfObj of an element of ConicAlgMag
ConicAlgMagNormOnRep := function(mRep)
	if mRep = 0 then # n(1_ConicAlg) = 1_ComRing
		return One(ComRing);
	elif mRep in [1..ConicAlg_rank] then
		return ComRingNormIndet(mRep);
	elif mRep in [ConicAlg_rank+1..2*ConicAlg_rank] then
		return ComRingNormIndet(mRep - ConicAlg_rank);
	elif IsList(mRep) then
		return ConicAlgMagNormOnRep(mRep[1]) * ConicAlgMagNormOnRep(mRep[2]);
	else
		return fail;
	fi;
end;

ConicAlgMagNorm := function(m)
	return ConicAlgMagNormOnRep(ExtRepOfObj(m));
end;

ConicAlgNorm := function(a)
	local coeffList, result, i, j, magmaEl, magmaEl2, coeff, coeff2;
	ReqConicAlgEl(a);
	coeffList := CoefficientsAndMagmaElements(a);
	result := Zero(ComRing);
	for i in [1..Length(coeffList)/2] do
		magmaEl := coeffList[2*i - 1]; # \in ConicAlgMag
		coeff := coeffList[2*i]; # \in ComRing
		result := result + coeff^2 * ConicAlgMagNorm(magmaEl); # norm(x_i)
		for j in [i+1..Length(coeffList)/2] do
			magmaEl2 := coeffList[2*j - 1]; # \in ConicAlgMag
			coeff2 := coeffList[2*j]; # \in ComRing
			result := result + coeff*coeff2 * ConicAlgMagTr(magmaEl * ConicAlgMagInv(magmaEl2)); # tr(x_i x_j') = linearisation of norm
		od;
	od;
	return result;
end;