### Functions that are not longer used but which I do not want to delete

## ----- Root systems -----

# a: A root in F4.
# Returns: List of all roots in F4 which are orthogonal to a.
F4OrthoRoots := function(a)
	local result, b;
	result := [];
	for b in F4Roots do
		if a*b = 0 then
			Add(result, b);
		fi;
	od;
	return result;
end;

F4PosOrthoRoots := function(a)
	return Intersection(F4PosRoots, F4OrthoRoots(a));
end;

# root: Element of F4Roots or [0,0,0,0]
# Returns: The corresponding root in G2
# Obsolete because a much easier formula without a case distinction is available
F4RootG2Coord := function(root)
	local sum;
	if not root in F4RootsZero then
		Error("Not a root in F4");
		return fail;
	fi;
	# L_2
	if root = [2, 0, 0, 0] then
		return [2, 1];
	# L_{-2}
	elif root = [-2, 0, 0, 0] then
		return [-2, -1];
	# ComRing-parts of the Brown algebra
	elif root = [-1, -1, -1, -1] then
		return [-1, -2];
	elif root = [-1, 1, 1, 1] then
		return [-1, 1];
	elif root = [1, -1, -1, -1] then
		return [1, -1];
	elif root = [1, 1, 1, 1] then
		return [1, 2];
	# L_0
	elif root[1] = 0 then
		sum := Sum(root);
		if sum = 0 then
			return [0, 0];
		elif sum > 0 then
			return [0, 1];
		else
			return [0, -1];
		fi;
	# Cubic-parts of L_{-1}
	elif root[1] = -1 then
		if Sum(root) = 0 then
			return [-1, 0];
		else
			return [-1, -1];
		fi;
	# Cubic-parts of L_1
	else
		if Sum(root) = 0 then
			return [1, 0];
		else
			return [1, 1];
		fi;
	fi;
end;

# root: in F4
# Returns list of all pairs [ root1, root2 ] s.t. root1 + root2 = root and
# root1 appears in F4Roots before root2
F4SumDecomp := function(root)
	local result, i, j, root1, root2;
	result := [];
	for i in [1..Length(F4Roots)] do
		root1 := F4Roots[i];
		for j in [i+1..Length(F4Roots)] do
			root2 := F4Roots[j];
			if root1 + root2 = root then
				Add(result, [root1, root2]);
			fi;
		od;
	od;
	return result;
end;

PrintF4SumDecomp := function(root)
	local entry;
	for entry in F4SumDecomp(root) do
		Print(entry[1], " * ", entry[2], "\n");
	od;
end;

# rootSystem: A root system (as a set of roots, not as a root system in GAP).
# rootList: A subset of rootSystem.
# Returns: The root subsystem generated by rootList.
GeneratedSubsystem := function(rootSystem, rootList)
	local vecspace, subspace;
	vecspace := VectorSpace(Rationals, rootSystem);
	subspace := Subspace(vecspace, rootList);
	return Intersection(rootSystem, subspace);
end;

# rootlist: A set of roots in F4RootsLC which forms a root subsystem
# Returns: True if this subsystem is of type A_2
SubsystemIsA2 := function(rootlist)
	local vecspace;
	vecspace := VectorSpace(Rationals, rootlist);
	return (Dimension(vecspace) = 2 and Length(rootlist) = 6);
end;

# root: A root in F4
# Returns: A list of all subsystems of F4 of type A2 that contain root.
AllA2Subsystems := function(root)
	local result, root2, subsys;
	result := [];
	for root2 in F4Roots do
		subsys := Set(GeneratedSubsystem(F4Roots, [root, root2]));
		if SubsystemIsA2(subsys) and not subsys in result then
			Add(result, subsys);
		fi;
	od;
	return result;
end;

# ----- List utilities -----

# rep: External representation of an element of a free magma. I.e., either an integer or
# a list [ rep1, rep2 ] where rep1, rep2 are external representations.
# Returns: The corresponding associative list.
# Example: 0 -> [ ], i -> [ i ], [ [ 1, 2 ], 3 ] -> [ 1, 2, 3 ]
AssocRepFromNonAssocRep := function(rep)
	if rep = 0 then
		return [];
	elif rep in Integers then
		return [ rep ];
	elif IsList(rep) then
		return Concatenation(AssocRepFromNonAssocRep(rep[1]), AssocRepFromNonAssocRep(rep[2]));
	else
		return fail;
	fi;
end;

## Tests
PrintLieComRel := function()
	local i, j, root1, root2, root3, a1, a2, a3, count;
	count := 0;
	for i in [1..Length(F4Roots)] do
		root1 := F4Roots[i];
		if root1 in F4ShortRoots then
			a1 := ConicAlgIndet(1);
		else
			a1 := ComRingIndet(1);
		fi;
		for j in [i+1..Length(F4Roots)] do
			root2 := F4Roots[j];
			if root2 in F4ShortRoots then
				a2 := ConicAlgIndet(2);
			else
				a2 := ComRingIndet(2);
			fi;
			root3 := root1 + root2;
			if root3 in F4ShortRoots then
				a3 := ConicAlgIndet(1);
			elif root3 in F4LongRoots then
				a3 := ComRingIndet(1);
			else
				continue;
			fi;
			count := count+1;
			Print(root1, " * ", root2, ": ", ApplyDDLaws(LieRootHomF4(root1, a1) * LieRootHomF4(root2, a2)), "\n");
			Print(root3, ": ", LieRootHomF4(root3, a3), "\n\n");
		od;
	od;
	Display(count);
end;

# Does not work because e.g. ConicAlgMatTr(a1*a1') = 2*n(a1)
TestWithoutTraces := function()
	local magEls, magEl, test1, test2;
	magEls := Concatenation(_AllConicAlgMagEls(Trace_MaxLength));
	for magEl in magEls do
		test1 := WithoutTraces(ConicAlgMagTr(magEl));
		test2 := ConicAlgMagEmb(magEl) + ConicAlgMagEmb(ConicAlgMagInv(magEl));
		if test1 <> test2 then
			return magEl;
		fi;
	od;
	return true;
end;

# ----- Cubic -----

# Returns the matrix corresponding to the representation of an element of Cubic
CubicRepToMatrix := function(rep)
	local x, u, g;
	x := rep[1]; # ComRing elements
	u := rep[2]; # ConicAlg elements
	g := TwistDiag;
	return [ [x[1], g[2]*u[3], g[3]*ConicAlgInv(u[2])], [g[1]*ConicAlgInv(u[3]), x[2], g[3]*u[1]],
			[g[1]*u[2], g[2]*ConicAlgInv(u[1]), x[3]]];
end;

# Return the matrix entry of cubicEl at position (i,j) "without TwistDiag"
CubicElCoeffMat := function(cubicEl, i, j)
	local k;
	if not (i in [1,2,3] and j in [1,2,3]) then
		return fail;
	fi;
	if i = j then
		return CubicComPart(cubicEl, i);
	else
		k := Difference([1,2,3], [i,j])[1]; # {1, 2, 3} = {i, j, k} as sets
		if [i, j, k] in CycPerm then
			return CubicConicPart(cubicEl, k);
		else
			return ConicAlgInv(CubicConicPart(cubicEl, k));
		fi;
	fi;
end;

# ----- Lie -----

# As LieGensAsModule, but does not use the formulas from [DMW, 5.20].
LieGensAsModuleUnsimplified := function(indetNum)
	local t1, a1, gens, root, cubic1, cubic2, cubicGens1, cubicGens2;
	t1 := ComRingIndet(2*indetNum + 1);
	a1 := ConicAlgIndet(2*indetNum + 1);
	gens := [LieXi, LieZeta];
	# Generators outside DD
	for root in F4Roots do
		if F4RootG2Coord(root) <> [0, 0] then
			if root in F4ShortRoots then
				Add(gens, LieRootHomF4(root, a1, true, true));
			else
				Add(gens, LieRootHomF4(root, t1, true, true));
			fi;
		fi;
	od;
	# Generators in DD
	cubicGens1 := CubicGensAsModule(2*indetNum + 1);
	cubicGens2 := CubicGensAsModule(2*indetNum + 2);
	for cubic1 in cubicGens1 do
		for cubic2 in cubicGens2 do
			Add(gens, Liedd(cubic1, cubic2));
		od;
	od;
	return gens;
end;

# ----- Group -----

# root: Root in F4.
InstallMethod(GrpWeylF4, [IsList, IsRingElement, IsRingElement, IsBool], function(root, a, b, naive)
	local inv;
	inv := GrpRootHomF4(-root, b, naive);
	return inv * GrpRootHomF4(root, a, naive) * inv;
end);

InstallMethod(GrpWeylF4, [IsList, IsRingElement, IsRingElement], function(root, a, b)
	return GrpWeylF4(root, a, b, false);
end);

# ----- Simplification -----

# L0el: Element of L0.
# Returns: The same element with ApplyDDLaws applied to the DD-part.
# Usually not needed because Simplify also applies ApplyDDLaws to the DD-part.
DeclareOperation("ApplyDDLaws", [IsL0Element, IsBool]);
InstallMethod(ApplyDDLaws, [IsL0Element, IsBool], function(L0el, applyDDRels)
	local rep, dd;
	rep := StructuralCopy(UnderlyingElement(L0el));
	dd := rep.dd;
	rep.dd := DDZero;
	return L0(rep) + ApplyDDLaws(dd, applyDDRels);
end);

# lieEl: Element of Lie.
# Returns: The same element with ApplyDDLaws applied to the DD-part.
# Usually not needed because Simplify also applies ApplyDDLaws to the DD-part.
DeclareOperation("ApplyDDLaws", [IsLieElement, IsBool]);
InstallMethod(ApplyDDLaws, [IsLieElement, IsBool], function(lieEl, applyDDRels)
	local rep;
	rep := StructuralCopy(UnderlyingElement(lieEl));
	rep.zero := ApplyDDLaws(rep.zero, applyDDRels);
	return Lie(rep);
end);

# ----- Tests -----

# Same as TestEquality, but uses the inverted list of lie algebra generators
DeclareOperation("TestEqualityY", [IsLieEndo, IsLieEndo, IsInt, IsInt]);
DeclareOperation("TestEqualityY", [IsLieEndo, IsLieEndo, IsInt]);
DeclareOperation("TestEqualityY", [IsLieEndo, IsLieEndo]);

InstallMethod(TestEqualityY, [IsLieEndo, IsLieEndo, IsInt, IsInt],
	function(lieEndo1, lieEndo2, comIndetNum, conicIndetNum)
		local genList;
		genList := LieGensAsLie(comIndetNum, conicIndetNum, true);
		return TestEqualityOnGenList(lieEndo1, lieEndo2, genList);
	end
);

InstallMethod(TestEqualityY, [IsLieEndo, IsLieEndo, IsInt], 
	function(lieEndo1, lieEndo2, indetNum)
		return TestEquality(lieEndo1, lieEndo2, indetNum, indetNum);
	end
);

InstallMethod(TestEqualityY, [IsLieEndo, IsLieEndo], 
	function(lieEndo1, lieEndo2)
		return TestEquality(lieEndo1, lieEndo2, ComRing_rank, ConicAlg_rank);
	end
);

# Prints all terms that have to be proven to be zero to show that
# d(a[ij], b[jl]) = d(1[ij], ab[jl]) for a cyclic permutation i,j,l of 1,2,3
TestDDRelation := function()
	local i, j, l, a1, a2, t, f, gen, a;
	i := 1;
	j := 2;
	l := 3;
	a1 := ConicAlgIndet(1);
	a2 := ConicAlgIndet(2);
	t := ComRingIndet(1);
	f := L0dd(CubicConicElMat(i, j, a1), CubicConicElMat(j, l, a2))
			- L0dd(CubicConicElMat(i, j, One(ConicAlg)), CubicConicElMat(j, l, a1*a2));
	for gen in BrownGensAsModule(3) do
		a := L0ElAsEndo(f, 1)(gen);
		if not IsZero(a) then
			Display(a);
		fi;
	od;
end;

# Prints { a[ij], b[jl], . } for certain i, j, l
TestDRelation := function()
	local indices, list, i, j, l, a, x, b, y, cubicGeneric;
	indices := [[1,1,2], [1,2,2], [1,3,2], [2,1,1], [2,2,1], [2,3,1]];
	for list in indices do
		i := list[1];
		j := list[2];
		l := list[3];
		if i = j then
			a := ComRingIndet(4);
			x := CubicComEl(i, a);
		else
			a := ConicAlgIndet(4);
			x := CubicConicElMat(i, j, a);
		fi;
		if j = l then
			b := ComRingIndet(5);
			y := CubicComEl(j, b);
		else
			b := ConicAlgIndet(5);
			y := CubicConicElMat(j, l, b);
		fi;
		cubicGeneric := CubicGenericEl(0);
		Display(list);
		Display(JordanD(x, y, cubicGeneric));
	od;
end;

# Uses indeterminates t_1, t_2, a_1, ..., a_4
DeclareOperation("LieEndoIsAuto", [IsLieEndo]);
InstallMethod(LieEndoIsAuto, [IsLieEndo], function(f)
	local lieGens1, lieGens2, isAuto, lieEl1, lieEl2, counter, total, test;
	lieGens1 := LieGensAsModule(1, 1);
	lieGens2 := LieGensAsModule(2, 3);
	isAuto := true;
	counter := 1;
	total := Length(lieGens1);
	for lieEl1 in lieGens1 do
		Print("Progress: ", counter, "/", total, "\n");
		for lieEl2 in lieGens2 do
			test := TestEquality(f(lieEl1 * lieEl2), f(lieEl1) * f(lieEl2), false);
			if not test then
				isAuto := false;
				Display("No proven equality f([a,b]) = [f(a), f(b)] for:");
				Display("a:");
				Display(lieEl1);
				Display("b:");
				Display(lieEl2);
				Display("Problem:");
				# Test equality again with error message - not efficient, but
				# a single equality test is not too expensive.
				TestEquality(f(lieEl1 * lieEl2), f(lieEl1) * f(lieEl2), true);
			fi;
		od;
		counter := counter + 1;
	od;
	return isAuto;
end);

# Documentation: See TestWeyl, but with onRootList
TestWeylOn := function(root, onRootList, w, wInv)
	return _WeylErrorAndParity(root, onRootList, w, wInv)[2];
end;

# w, wInv: Elements of LieEndo. It is assumed that wInv = w^-1.
# Returns: true if w can be proven to be a root-Weyl element.
# Otherwise the output is a list consisting of lists [baseRoot, errorList] where
# baseRoot is a root and errorList is the list of Lie algebra elements which have to
# be proven to be zero.
# Uses indeterminates a_1, t_1, a_{ConicAlg_rank}, t_{ComRing_rank}
TestWeyl := function(root, w, wInv)
	return TestWeylOn(root, F4Roots, w, wInv);
end;


# root: Root in F4.
# Returns true if GrpStandardWeylF4(root) can be proven to be a Weyl element,
# otherwise returns a list of error terms.
# Uses indeterminates a_1, t_1, a_{ConicAlg_rank}, t_{ComRing_rank}
TestWeylStandard := function(root)
	local w, wInv;
	w := GrpStandardWeylF4(root);
	wInv := GrpStandardWeylF4(root, -1);
	return TestWeyl(root, w, wInv);
end;

TestLongWeyl := function()
	local root, testResult, i;
	testResult := [];
	for i in [1..Length(F4PosLongRoots)] do
		root := F4PosLongRoots[i];
		Print(i, "/", Length(F4PosLongRoots), "\n");
		Add(testResult, [root, TestWeylStandard(root)]);
	od;
	return testResult;
end;

TestShortWeyl := function()
	local root, testResult, i;
	testResult := [];
	for i in [1..Length(F4PosShortRoots)] do
		root := F4PosShortRoots[i];
		Print(i, "/", Length(F4PosShortRoots), "\n");
		Add(testResult, [root, TestWeylStandard(root)]);
	od;
	return testResult;
end;

# Returns a list of relations which have to be verified by hand to prove that
# the parities of GrpStandardWeylF4(F4SimpleRoots[i]) adhere to F4ParityList
# This is essentially a duplicate.
TestStandardWeylParity := function(i)
	local d, w, wInv, errorList, error, j, baseRoot, a, x, b, y;
	d := F4SimpleRoots[i];
	w := GrpStandardWeylF4(d);
	wInv := GrpStandardWeylF4(d, -1);
	errorList := [];
	for j in [1..Length(F4Roots)] do
		baseRoot := F4Roots[j];
		if baseRoot in F4ShortRoots then
			a := ConicAlgIndet(1);
		else
			a := ComRingIndet(1);
		fi;
		x := GrpRootHomF4(baseRoot, a);
		b := a;
		if F4ParityList[j][i][1] = -1 then
			b := -b;
		fi;
		if F4ParityList[j][i][2] = -1 then
			b := ConicAlgInv(b);
		fi;
		y := GrpRootHomF4(F4Refl(baseRoot, d), b);
		error := TestEqualityPiecesOnList([[wInv*x*w, y]]);
		if not IsEmpty(error) then
			Print(baseRoot, " -> ", F4Refl(baseRoot, d), ":\n");
			Display(error);
			errorList := Concatenation(errorList, error);
		fi;
	od;
	return errorList;
end;

## Tests for abstract parametrisation strategy

# relations: A list of lists [l1, l2] where l1 and l2 are lists containing elements
# from [-4, -3, -2, -1, 1, 2, 3, 4] or elements from LieEndo
# The function calls TestEqualityPiecesOnList on the list weylRelations which is obtained from relations
# by replacing any list [g1, g2, ...] by the automorphism g1 * g2 * ...
# If gi is a positive integer, it is interpreted as w_gi. If it is a negative integer,
# it is interpreted as w_(-gi)^-1. Here wj = GrpStandardWeyl(F4SimpleRoots[j]).
# Uses indeterminates t_1, a_1.
TestWeylRelations := function(relations)
	local w, wInv, i, weylRelations;
	w := [];
	wInv := [];
	for i in [1..Length(F4SimpleRoots)] do
		w[i] := GrpStandardWeylF4(F4SimpleRoots[i]);
		wInv[i] := GrpStandardWeylF4(F4SimpleRoots[i], -1);
	od;
	weylRelations := List(relations, x -> List(x, function(list)
		local auto, i;
		auto := GrpOne;
		for i in list do
			if not IsInt(i) then
				auto := auto * i;
			elif i>0 then
				auto := auto * w[i];
			else
				auto := auto * wInv[-i];
			fi;
		od;
		return auto;
	end));
	return TestEqualityPiecesOnList(weylRelations);
end;

# Prints all relations which have to be proven by hand to verify the braid relations for
# the standard Weyl elements w.r.t. F4SimpleRoots.
# Uses indeterminates a_1, t_1
TestBraidRel := function()
	return TestWeylRelations([
		[[1, 2, 1], [2, 1, 2]], [[1, 3], [3, 1]], [[1, 4], [4, 1]],
		[[2, 3, 2, 3], [3, 2, 3, 2]], [[2, 4], [4, 2]],
		[[3, 4, 3], [4, 3, 4]]
	]);
end;

# Denote by wi the standard Weyl element for F4SimpleRoots[i]
# This function prints all relations which have to be proven by hand to verify the
# following assertions:
# wi^(wj^2) = wi^-1, wj^(wi^1) = wj^-1 for (i, j) \in {(1,2), (3,4)}
# w2^(w3^2) = w2, w3^(w2^2) = w3^-1
# Note that for i, j with |i-j| > 1, we know from the braid relations that
# wi^(wj^2) = wi.
# Uses indeterminates t_1, a_1.
TestWeylSquareOnWeyl := function()
	return TestWeylRelations([
		[[-1, -1, 2, 1, 1], [-2]], [[-2, -2, 1, 2, 2], [-1]],
		[[-3, -3, 4, 3, 3], [-4]], [[-4, -4, 3, 4, 4], [-3]],
		[[-2, -2, 3, 2, 2], [-3]], [[-3, -3, 2, 3, 3], [2]]
	]);
end;

# Denote by wi the standard Weyl element for F4SimpleRoots[i] by d2, d3 the simple
# roots of index 2 and 3, respectively.
# This function prints all relations which have to be proven by hand to verify the
# following assertions:
# GrpRootHomF4(d2, t1)^(w1^2) = GrpRootHomF4(d2, -t1)
# GrpRootHomF4(d2, t1)^(w2^2) = GrpRootHomF4(d2, t1)
# GrpRootHomF4(d2, t1)^(w3^2) = GrpRootHomF4(d2, t1)
# GrpRootHomF4(d3, a1)^(w2^2) = GrpRootHomF4(d3, -a1)
# GrpRootHomF4(d3, a1)^(w2^2) = GrpRootHomF4(d3, a1)
# GrpRootHomF4(d3, a1)^(w2^2) = GrpRootHomF4(d3, -a1)
# In particular, w1^2, ..., w4^2 normalise the root groups U_d2 and U_d3
# Uses indeterminates t_1, a_1, t_(ComRing_rank), a_(ConicAlg_rank).
TestWeylSquareNormalise := function()
	local a, t, hom2, hom3;
	a := ConicAlgIndet(1);
	t := ComRingIndet(1);
	hom2 := x -> GrpRootHomF4(F4SimpleRoots[2], x);
	hom3 := x -> GrpRootHomF4(F4SimpleRoots[3], x);
	return TestWeylRelations([
		[[-1, -1, hom2(t), 1, 1], [hom2(-t)]],
		[[-2, -2, hom2(t), 2, 2], [hom2(t)]],
		[[-3, -3, hom2(t), 3, 3], [hom2(t)]],
		[[-2, -2, hom3(a), 2, 2], [hom3(-a)]],
		[[-3, -3, hom3(a), 3, 3], [hom3(a)]],
		[[-4, -4, hom3(a), 4, 4], [hom3(-a)]]
	]);
end;

# Denote by wi the standard Weyl element for F4SimpleRoots[i] by d2, d3 the simple
# roots of index 2 and 3, respectively.
# This function prints all relations which have to be proven by hand to verify the
# following assertions:
# - U_d2 is centralised by the following elements:
# -- w4
# -- w4^{w3*w2*w1}
# -- w([1,2,3,2,1,4,3,2,1,3,2,4,3,2,1])
# - U_d3 is centralised by the following elements:
# -- w1
# -- w2^{w3*w4}
# - w([4,3,2,1,3,2,3,4,3,2,1,3,2,3,4]) acts on U_d3 as ConicAlgInv.
TestStabNormalise := function()
	local a, t, hom2, hom3, stab21, stab22, stab23, stab31, stab32, stab33;
	a := ConicAlgIndet(1);
	t := ComRingIndet(1);
	hom2 := x -> GrpRootHomF4(F4SimpleRoots[2], x);
	hom3 := x -> GrpRootHomF4(F4SimpleRoots[3], x);
	# Reduced representations of generators of stabilizer of d2
	stab21 := [4]; # \sigma([0,1,1,0])
	stab22 := [-1, -2, -3, 4, 3, 2, 1]; # \sigma([0,-1,0,1])
	stab23 := [1,2,3,2,1,4,3,2,1,3,2,4,3,2,1]; # \sigma([0,0,0,-2])
	# Reduced representations of generators of stabilizer of d3
	stab31 := [1]; # \sigma([-1,-1,1,1])
	stab32 := [-4,-3,2,3,4]; # \sigma([0,0,-2,0])
	stab33 := [4,3,2,1,3,2,3,4,3,2,1,3,2,3,4]; # \sigma([0,0,1,-1])
	return TestWeylRelations([
		# [Concatenation(-Reversed(stab21), [hom2(t)], stab21), [hom2(t)]],
		# [Concatenation(-Reversed(stab22), [hom2(t)], stab22), [hom2(t)]],
		# [Concatenation(-Reversed(stab23), [hom2(t)], stab23), [hom2(t)]],
		# [Concatenation(-Reversed(stab31), [hom3(a)], stab31), [hom3(a)]],
		# [Concatenation(-Reversed(stab32), [hom3(a)], stab32), [hom3(a)]],
		[Concatenation(-Reversed(stab33), [hom3(a)], stab33), [hom3(ConicAlgInv(a))]]
	]);
end;

## Parity map

# Returns a table par such that par[i][j] is the parity of w_{F4SimpleRoots[j]} on
# U_{F4Roots[i]}
_ComputeF4ParityList := function()
	local d1Par, d2Par, d3Par, d4Par, dPar, root, d1, d2, d3, d4, par, list, j;
	d1 := F4SimpleRoots[1];
	d2 := F4SimpleRoots[2];
	d3 := F4SimpleRoots[3];
	d4 := F4SimpleRoots[4];
	d1Par := NewDictionary(F4Roots[1], true, F4Roots);
	d2Par := NewDictionary(F4Roots[1], true, F4Roots);
	d3Par := NewDictionary(F4Roots[1], true, F4Roots);
	d4Par := NewDictionary(F4Roots[1], true, F4Roots);
	# d1
	for root in F4PosRoots do
		if root in [d1, d1+d2, d1+d2+d3, d1+d2+2*d3, d1+d2+2*d3+d4, d1+d2+2*(d3+d4),
			d1+3*d2+4*d3+2*d4] then
			AddDictionary(d1Par, root, [-1, 1]);
		else
			AddDictionary(d1Par, root, [1, 1]);
		fi;
		AddDictionary(d1Par, -root, LookupDictionary(d1Par, root));
	od;
	# d2
	for root in F4PosRoots do
		if root in [d1, d2, d2+d3, d2+d3+d4, d1+d2+2*d3, d1+d2+2*d3+d4,
			d1+d2+2*(d3+d4), d1+2*d2+4*d3+2*d4] then
			AddDictionary(d2Par, root, [-1, 1]);
		else
			AddDictionary(d2Par, root, [1,1]);
		fi;
		AddDictionary(d2Par, -root, LookupDictionary(d2Par, root));
	od;
	# d3
	for root in F4PosRoots do
		if root in [d2, d3, d1+d2, d2+2*d3, d1+d2+2*d3, d2+2*d3+d4,
			d1+d2+2*d3+d4, d1+2*(d2+d3)+d4, d1+2*(d2+d3+d4), d1+2*d2+4*d3+2*d4] then
			AddDictionary(d3Par, root, [-1, 1]);
		elif root in [d2+d3, d1+d2+d3, d1+2*d2+3*d3+2*d4] then
			AddDictionary(d3Par, root, [-1, -1]);
		else
			AddDictionary(d3Par, root, [1,1]);
		fi;
		AddDictionary(d3Par, -root, LookupDictionary(d3Par, root));
	od;
	# d4
	for root in F4PosRoots do
		if root in [d3, d4, d2+d3, d1+d2+d3, d2+2*d3, d1+d2+2*d3, d1+2*(d2+d3),
			d2+2*(d3+d4), d1+d2+2*(d3+d4), d1+2*(d2+d3+d4), d1+2*d2+3*d3+2*d4] then
			AddDictionary(d4Par, root, [-1, 1]);
		elif root in [d2+2*d3+d4, d1+d2+2*d3+d4, d1+2*(d2+d3)+d4] then
			AddDictionary(d4Par, root, [-1, -1]);
		else
			AddDictionary(d4Par, root, [1,1]);
		fi;
		AddDictionary(d4Par, -root, LookupDictionary(d4Par, root));
	od;
	# Build par
	dPar := [d1Par, d2Par, d3Par, d4Par];
	par := [];
	for root in F4Roots do
		list := [];
		for j in [1..4] do
			Add(list, LookupDictionary(dPar[j], root));
		od;
		Add(par, list);
	od;
	return par;
end;
