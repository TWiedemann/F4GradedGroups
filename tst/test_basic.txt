### Test executed with ConicAlg_rank = ComRing_rank = 6, Trace_MaxLength = 3
### Test with Test(filepath, rec( width := 500000 ))

### This file tests the main functions in the user interface.
### Runtime: Negligible.

### ----- Basic elements -----

## Elements of Conic algebra
gap> a1 := ConicAlgIndet(1);
(1)*a1
gap> a2 := ConicAlgIndet(2);; a3 := ConicAlgIndet(3);;

## Elements of commutative ring
gap> t1 := ComRingIndet(1);
t1
gap> t2 := ComRingIndet(2);; t3 := ComRingIndet(3);;
gap> g1 := ComRingGamIndet(1);
g1

### ----- Conic algebra structure -----

## Conjugation
gap> ConicAlgInv(a1);
(1)*a1'
gap> last = ConicAlgInvIndet(1);
true
gap> ConicAlgInv(a1*a2);
(1)*(a2'*a1')

## Norm
gap> ConicAlgNorm(a1);
n(a1)
gap> ConicAlgNorm(ConicAlgInv(a1));
n(a1)
gap> ConicAlgNorm(a1*a2);
n(a1)*n(a2)
gap> ConicAlgNorm(One(ConicAlg)) = One(ComRing);
true
gap> ConicAlgNorm(t1*a1);
t1^2*n(a1)

## Trace
gap> ConicAlgTr(a1);
tr(a1)
gap> ConicAlgTr(One(ConicAlg));
2
gap> ConicAlgTr(a1*a2);
tr(a1a2)
gap> ConicAlgTr(a1+a2);
tr(a1)+tr(a2)
gap> ConicAlgTr(ConicAlgInv(a1)*a2);  # = tr(a1'a2) !
tr(a1a2')
gap> ConicAlgTr(t1*a1);
t1*tr(a1)
gap> ConicAlgTr(a1*a1*a2);
tr(a1a1a2)
gap> ConicAlgTr(a1*ConicAlgInv(a1)*a2);
n(a1)*tr(a2)
gap> ConicAlgTr(a1*a2*ConicAlgInv(a1));
n(a1)*tr(a2)

## Linearisation of norm
gap> ConicAlgNorm(a1+a2);
n(a1)+n(a2)+tr(a1a2')
gap> ConicAlgNormLin(a1, a2);
tr(a1a2')

### ----- Cubic norm (pair) structure ---

## Elements
gap> CubicComEl(1, t1);
(t1)[11]
gap> CubicComEl(2, t1);
(t1)[22]
gap> CubicComEl(3, t1);
(t1)[33]
gap> CubicConicEl(1, a1);
((1)*a1)[23]
gap> CubicConicEl(2, a1);
((1)*a1)[31]
gap> CubicConicEl(3, a1);
((1)*a1)[12]
gap> CubicConicElMat(1, 2, a1);
((1)*a1)[12]
gap> CubicConicElMat(2, 1, a1);
((1)*a1')[12]
gap> CubicConicElMat(1, 3, a1);
((1)*a1')[31]
gap> CubicConicElMat(2, 3, a1);
((1)*a1)[23]
gap> cubicGen1 := CubicGenericEl(0);
(t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12]
gap> cubicGen2 := CubicGenericEl(1);
(t4)[11]+(t5)[22]+(t6)[33]+((1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12]

## Norm
gap> CubicNorm(cubicGen1);
g1*g2*g3*tr(a1a2a3)-g1*g2*t3*n(a3)-g1*g3*t2*n(a2)-g2*g3*t1*n(a1)+t1*t2*t3

## Adjoint
gap> CubicAdj(cubicGen1);
(-g2*g3*n(a1)+t2*t3)[11]+(-g1*g3*n(a2)+t1*t3)[22]+(-g1*g2*n(a3)+t1*t2)[33]+((-t1)*a1+(g1)*(a3'*a2'))[23]+((-t2)*a2+(g2)*(a1'*a3'))[31]+((-t3)*a3+(g3)*(a2'*a1'))[12]

## Cross product
gap> CubicCross(cubicGen1, cubicGen2);
(-g2*g3*tr(a1a4')+t2*t6+t3*t5)[11]+(-g1*g3*tr(a2a5')+t1*t6+t3*t4)[22]+(-g1*g2*tr(a3a6')+t1*t5+t2*t4)[33]+((-t4)*a1+(-t1)*a4+(g1)*(a3'*a5')+(g1)*(a6'*a2'))[23]+((-t5)*a2+(-t2)*a5+(g2)*(a1'*a6')+(g2)*(a4'*a3'))[31]+((-t6)*a3+(-t3)*a6+(g3)*(a2'*a4')+(g3)*(a5'*a1'))[12]

## Bilinear trace
gap> CubicBiTr(cubicGen1, cubicGen2);
g1*g2*tr(a3a6')+g1*g3*tr(a2a5')+g2*g3*tr(a1a4')+t1*t4+t2*t5+t3*t6

## Jordan maps 
gap> JordanU(cubicGen1, cubicGen2);
(g1*g2*g3*tr(a2a3a4)+g1*g2*t1*tr(a3a6')+g1*g2*t5*n(a3)+g1*g3*t1*tr(a2a5')+g1*g3*t6*n(a2)+t1^2*t4)[11]+(g1*g2*g3*tr(a1a5a3)+g1*g2*t2*tr(a3a6')+g1*g2*t4*n(a3)+g2*g3*t2*tr(a1a4')+g2*g3*t6*n(a1)+t2^2*t5)[22]+(g1*g2*g3*tr(a1a2a6)+g1*g3*t3*tr(a2a5')+g1*g3*t4*n(a2)+g2*g3*t3*tr(a1a4')+g2*g3*t5*n(a1)+t3^2*t6)[33]+((g1*g2*tr(a3a6')+g1*g3*tr(a2a5')+g2*g3*tr(a1a4')+t2*t5+t3*t6)*a1+(-g2*g3*n(a1)+t2*t3)*a4+(g1*t4)*(a3'*a2')+(g1*t3)*(a3'*a5')+(g1*t2)*(a6'*a2')+(-g1*g2)*(a6'*(a3*a1))+(-g1*g3)*((a1*a2)*a5'))[23]+((g1*g2*tr(a3a6')+g1*g3*tr(a2a5')+g2*g3*tr(a1a4')+t1*t4+t3*t6)*a2+(-g1*g3*n(a2)+t1*t3)*a5+(g2*t5)*(a1'*a3')+(g2*t1)*(a1'*a6')+(g2*t3)*(a4'*a3')+(-g2*g3)*(a4'*(a1*a2))+(-g1*g2)*((a2*a3)*a6'))[31]+((g1*g2*tr(a3a6')+g1*g3*tr(a2a5')+g2*g3*tr(a1a4')+t1*t4+t2*t5)*a3+(-g1*g2*n(a3)+t1*t2)*a6+(g3*t6)*(a2'*a1')+(g3*t2)*(a2'*a4')+(g3*t1)*(a5'*a1')+(-g1*g3)*(a5'*(a2*a3))+(-g2*g3)*((a3*a1)*a4'))[12]
gap> JordanU(CubicConicEl(1, a1), CubicConicEl(2, a2));
0_J
gap> JordanU(CubicConicEl(1, a1), CubicComEl(2, t2));
(g2*g3*t2*n(a1))[33]
gap> JordanULin(cubicGen1, cubicGen2, cubicGen1);
(g1*g2*g3*tr(a1a2a6)+g1*g2*g3*tr(a1a5a3)+g1*g2*t1*tr(a3a6')+g1*g2*t2*tr(a3a6')+2*g1*g2*t4*n(a3)+g1*g3*t1*tr(a2a5')+g1*g3*t3*tr(a2a5')+2*g1*g3*t4*n(a2)+2*t1^2*t4)[11]+(g1*g2*g3*tr(a1a2a6)+g1*g2*g3*tr(a2a3a4)+g1*g2*t1*tr(a3a6')+g1*g2*t2*tr(a3a6')+2*g1*g2*t5*n(a3)+g2*g3*t2*tr(a1a4')+g2*g3*t3*tr(a1a4')+2*g2*g3*t5*n(a1)+2*t2^2*t5)[22]+(g1*g2*g3*tr(a1a5a3)+g1*g2*g3*tr(a2a3a4)+g1*g3*t1*tr(a2a5')+g1*g3*t3*tr(a2a5')+2*g1*g3*t6*n(a2)+g2*g3*t2*tr(a1a4')+g2*g3*t3*tr(a1a4')+2*g2*g3*t6*n(a1)+2*t3^2*t6)[33]+((g1*g2*tr(a3a6')+g1*g3*tr(a2a5')+t2*t5+t2*t6+t3*t5+t3*t6)*a1+(2*g1*g2*n(a3)+2*g1*g3*n(a2)+2*g2*g3*n(a1)+t2^2+t3^2)*a4+(g1*t5+g1*t6)*(a3'*a2')+(g1*t1+g1*t2)*(a3'*a5')+(-g1*g2)*(a3'*(a3*a4))+(-g1*g2)*(a3'*(a6*a1))+(g1*t1+g1*t3)*(a6'*a2')+(-g1*g3)*((a1*a5)*a2')+(-g1*g3)*((a4*a2)*a2'))[23]+((g1*g2*tr(a3a6')+g2*g3*tr(a1a4')+t1*t4+t1*t6+t3*t4+t3*t6)*a2+(2*g1*g2*n(a3)+2*g1*g3*n(a2)+2*g2*g3*n(a1)+t1^2+t3^2)*a5+(g2*t4+g2*t6)*(a1'*a3')+(g2*t2+g2*t3)*(a1'*a6')+(-g2*g3)*(a1'*(a1*a5))+(-g2*g3)*(a1'*(a4*a2))+(g2*t1+g2*t2)*(a4'*a3')+(-g1*g2)*((a2*a6)*a3')+(-g1*g2)*((a5*a3)*a3'))[31]+((g1*g3*tr(a2a5')+g2*g3*tr(a1a4')+t1*t4+t1*t5+t2*t4+t2*t5)*a3+(2*g1*g2*n(a3)+2*g1*g3*n(a2)+2*g2*g3*n(a1)+t1^2+t2^2)*a6+(g3*t4+g3*t5)*(a2'*a1')+(g3*t1+g3*t3)*(a2'*a4')+(-g1*g3)*(a2'*(a2*a6))+(-g1*g3)*(a2'*(a5*a3))+(g3*t2+g3*t3)*(a5'*a1')+(-g2*g3)*((a3*a4)*a1')+(-g2*g3)*((a6*a1)*a1'))[12]
gap> last = JordanD(cubicGen1, cubicGen1, cubicGen2);
true

### ----- Brown algebra -----
gap> brown1 := BrownElFromTuple(t1, cubicGen1, cubicGen2, t2);
[ t1, (t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12], (t4)[11]+(t5)[22]+(t6)[33]+((1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12], t2 ]
gap> t1*brown1;
[ t1^2, (t1^2)[11]+(t1*t2)[22]+(t1*t3)[33]+((t1)*a1)[23]+((t1)*a2)[31]+((t1)*a3)[12], (t1*t4)[11]+(t1*t5)[22]+(t1*t6)[33]+((t1)*a4)[23]+((t1)*a5)[31]+((t1)*a6)[12], t1*t2 ]
gap> brown1 + BrownElFromTuple(t2, CubicZero, CubicConicEl(1, a1), t3);
[ t1+t2, (t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12], (t4)[11]+(t5)[22]+(t6)[33]+((1)*a1+(1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12], t2+t3 ]

### ----- L_0 -----

## Elements
gap> DDZero;
0_{DD}
gap> L0Zero;
0_{L_0}
gap> L0Zero = DDZero;
false
gap> L0Xi - L0Zeta;
xi+(-1)*zeta
gap> last + t1*L0Zeta + L0dd(cubicGen1, cubicGen2);
dd_{(t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12],(t4)[11]+(t5)[22]+(t6)[33]+((1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12]}+xi+(t1-1)*zeta
gap> DDdd(cubicGen1, cubicGen2);
dd_{(t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12],(t4)[11]+(t5)[22]+(t6)[33]+((1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12]}

## ApplyDDLaws
gap> ApplyDDLaws(DDdd(CubicConicEl(2, a1), CubicComEl(3, t1)), true);
dd_{(1)[11],((t1)*a1)[31]}
gap> ApplyDDLaws(DDdd(CubicConicElMat(1,2, a1), CubicConicElMat(2,3, a2)), true);
dd_{(1)[11],((g2)*(a2'*a1'))[31]}
gap> ApplyDDLaws(DDdd(CubicConicElMat(1,2, a1), CubicConicElMat(1,3, a2)), true);
dd_{(1)[22],((g1)*(a1'*a2))[23]}
gap> ApplyDDLaws(DDdd(CubicConicElMat(1,2, a1), CubicComEl(3, t1)), true);
0_{L_0}

## Embeddings
gap> L0dd(cubicGen1, cubicGen2) = DDToL0Emb(DDdd(cubicGen1, cubicGen2));
true
gap> CubicPosToL0Emb(cubicGen1) + L0Xi;
ad^+_{(t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12]}+xi
gap> CubicNegToL0Emb(cubicGen1) + L0Xi;
ad^-_{(t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12]}+xi

### ----- Lie -----

## Elements
gap> LieX + t1*LieY;
(1)*x + (t1)*y
gap> LieX*LieY;
xi
gap> LieY*LieX;
(-1)*xi
gap> LieX*(t1*LieY);
(t1)*xi
gap> t1*LieX + 5*LieY + LieZeta - LieY;
(t1)*x + zeta + (4)*y
gap> Display(last);
-2 part: t1
 0 part: zeta
 2 part: 4
gap> LieZeta = L0Zeta;
false
gap> LiePart(Liedd(CubicConicEl(1, a1), CubicConicEl(2, a2)) + LieX, 0);
dd_{((1)*a1)[23],((1)*a2)[31]}

## Embeddings
gap> BrownNegToLieEmb(brown1);
[ t1, (t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12], (t4)[11]+(t5)[22]+(t6)[33]+((1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12], t2 ]_-
gap> BrownPosToLieEmb(brown1);
[ t1, (t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12], (t4)[11]+(t5)[22]+(t6)[33]+((1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12], t2 ]_+
gap> LieX*last;
[ -t1, (-t1)[11]+(-t2)[22]+(-t3)[33]+((-1)*a1)[23]+((-1)*a2)[31]+((-1)*a3)[12], (-t4)[11]+(-t5)[22]+(-t6)[33]+((-1)*a4)[23]+((-1)*a5)[31]+((-1)*a6)[12], -t2 ]_-
gap> BrownNegToLieEmb(brown1) * BrownPosToLieEmb(brown1);
(2)*dd_{(t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12],(t4)[11]+(t5)[22]+(t6)[33]+((1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12]}+ad^+_{(-2*g2*g3*n(a4)-2*t1*t2+2*t5*t6)[11]+(-2*g1*g3*n(a5)-2*t2^2+2*t4*t6)[22]+(-2*g1*g2*n(a6)-2*t2*t3+2*t4*t5)[33]+((-2*t2)*a1+(-2*t4)*a4+(2*g1)*(a6'*a5'))[23]+((-2*t2)*a2+(-2*t5)*a5+(2*g2)*(a4'*a6'))[31]+((-2*t2)*a3+(-2*t6)*a6+(2*g3)*(a5'*a4'))[12]}+ad^-_{(-2*g2*g3*n(a1)-2*t1*t4+2*t2*t3)[11]+(-2*g1*g3*n(a2)+2*t1*t3-2*t1*t5)[22]+(-2*g1*g2*n(a3)+2*t1*t2-2*t1*t6)[33]+((-2*t1)*a1+(-2*t1)*a4+(2*g1)*(a3'*a2'))[23]+((-2*t2)*a2+(-2*t1)*a5+(2*g2)*(a1'*a3'))[31]+((-2*t3)*a3+(-2*t1)*a6+(2*g3)*(a2'*a1'))[12]}+(g1*g2*tr(a3a6')+g1*g3*tr(a2a5')+g2*g3*tr(a1a4')-t1*t2+t1*t4+t2*t5+t3*t6)*xi+(-2*g1*g2*tr(a3a6')-2*g1*g3*tr(a2a5')-2*g2*g3*tr(a1a4')+2*t1*t2-2*t1*t4-2*t2*t5-2*t3*t6)*zeta

## dd
gap> Liedd(cubicGen1, cubicGen2);
dd_{(t1)[11]+(t2)[22]+(t3)[33]+((1)*a1)[23]+((1)*a2)[31]+((1)*a3)[12],(t4)[11]+(t5)[22]+(t6)[33]+((1)*a4)[23]+((1)*a5)[31]+((1)*a6)[12]}
gap> last = L0dd(cubicGen1, cubicGen2);
false
